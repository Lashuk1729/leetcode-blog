[{"id":"3216915","title":"First missing positive + Bit manipulation [Easy to understand]","url":"/discuss/topic/3216915/first-missing-positive-bit-manipulation-easy-to-understand","questionTitle":"Minimum Impossible OR","post":{"creationDate":1677040948},"post_data":{"id":3216915,"title":"First missing positive + Bit manipulation [Easy to understand]","solutionTags":[{"name":"C++"}],"post":{"id":5030542,"content":"# Intuition\nThis problem seems similar to [First Missing Positive](https://leetcode.com/problems/first-missing-positive/). Here is a solution to that probelm:\n\n```\nint firstMissingPositive(vector<int>& nums) {\n    unordered_set<int> numSet(nums.begin(),nums.end());\n    int i = 1;\n    while (i <= nums.size()){\n        if (!numSet.count(i)) return i;\n        i++;\n    }\n    return i;\n}\n```\n# Observation\nOur solution is similar to the above in spirit. The crucial thing to notice is that if we have just powers of 2, we can construct all numbers upto the next power of 2 by their OR.\n\nFor example, given the array `[1,2,4,8,16]`, we can do `OR` between various elements to construct all numbers from 1 to 31. So the presence of other numbers in the middle like 3,5,6 etc. does not change the range of possible numbers. Hence these are the only ones that need to be checked.\n\n# Code\n```\nclass Solution {\npublic:\n    int minImpossibleOR(vector<int>& nums) \n    {\n        unordered_set<int> numSet(nums.begin(),nums.end());\n        int cur = 1;\n        while (cur<INT_MAX)\n        {\n            if (!numSet.count(cur)) return cur;\n            cur <<= 1;\n        }\n        return INT_MAX;\n    }\n};\n```","creationDate":1677040948}}},{"id":"3216829","title":"K Sum solution explained","url":"/discuss/topic/3216829/k-sum-solution-explained","questionTitle":"4Sum","post":{"creationDate":1677038671},"post_data":{"id":3216829,"title":"K Sum solution explained","solutionTags":[{"name":"C++"}],"post":{"id":5030396,"content":"# Explanation\nWe will generalize 2-sum to K-Sum.\n\n## Revision of 2 Sum\nThere are two main ways to solve 2 Sum in $O(n)$ time. Let us look at both. We will not look at finding whether two sum exists but return all such pairs (with repitition if repititions are present). For the 2nd method, let us assume that the array was given to us in sorted order. We will talk about this assumption later.\n\n### 2 Sum using HashSet: $O(n)$ time, $O(n)$ space\n```\nvector<vector<int>> twoSum(vector<int>nums, target)\n{\n    vector<vector<int>> res;\n    unordered_set<int> complements;\n    for (int n: nums)\n    {\n        if (complements.count(n)) vec.push_back({target-n, target});\n        complements.insert(target-n);\n    }\n    return res;\n}\n```\n\n### 2 Sum using double pointer: $O(n)$ time, $O(1)$ space\n**Note:** We had assumed `nums` to be pre-sorted.\n```\nvector<vector<int>> twoSum(vector<int>nums, target)\n{\n    vector<vector<int>> res;\n    int lo=0, hi=nums.size()-1;\n    while(lo<hi)\n    {\n        int cur = nums[lo] + nums[hi];\n        if (cur==target)\n        {\n            res.push_back({nums[lo],nums[hi]});\n            lo++;\n            hi--;\n        }\n        else if (cur<target) lo++;\n        else hi--;\n    }\n    return res;\n}\n```\n\nNow to generalize this to K-Sum we can have a recursive function such that `KSum` for `K` will be created using `KSum` for `K-1`. When we reach `K=2` we will use the `twoSum` that we have written earlier.\n\nNow the crucial thing to note is that for `K=3,4,5,...` we will always have a situation where `TC` is at least $O(n^2)$, hence it makes sense to pre-sort array in $O(n\\log(n))$ time and use the 2nd method. It also helps in keeping track of unique subsets because otherwise we will have to sort the subset each time before adding to `res`.\n\n\n# Code\n```\n#define ll long long\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \n    {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        return KSum(nums, target, 4, 0);\n    }\n    vector<vector<int>> KSum(vector<int>&nums, ll target, \\\n                             int K, int start)\n    {\n        if (start>=nums.size()) return {};\n        if (target<(ll)nums[start]*K || target>(ll)nums.back()*K) return {};\n        if (K==2) return twoSum(nums, target, start);\n        set<vector<int>> res;\n        for (int i=start; i<nums.size(); i++)\n        {\n            vector<vector<int>> kSumPrev = KSum(nums, target-nums[i], K-1, i+1);\n            for (auto subset: kSumPrev)\n            {\n                subset.push_back(nums[i]);\n                res.insert(subset);\n            }\n        }\n        return vector<vector<int>>(res.begin(),res.end());\n    }\n    vector<vector<int>> twoSum(vector<int>&nums, ll target, int start)\n    {\n        vector<vector<int>> res;\n        int lo=start, hi=nums.size()-1;\n        while(lo<hi)\n        {\n            ll cur = (ll)nums[lo] + nums[hi];\n            if (cur==target)\n            {\n                res.push_back({nums[lo],nums[hi]});\n                lo++;\n                hi--;\n            }\n            else if (cur<target) lo++;\n            else hi--;\n        }\n        return res;\n    }\n};\n```\n# Complexity\n`TC`: $O(n^3)$\n`SC`: $O(n)$","creationDate":1677038671}}},{"id":"3216706","title":"Binary search with proper explanation","url":"/discuss/topic/3216706/binary-search-with-proper-explanation","questionTitle":"Capacity To Ship Packages Within D Days","post":{"creationDate":1677034577},"post_data":{"id":3216706,"title":"Binary search with proper explanation","solutionTags":[{"name":"C++"},{"name":"Binary Search"}],"post":{"id":5030218,"content":"# Intuition\\r\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\nWe need to find the minimum possible capacity that will work. So, we can think of the problem as a search problem with a test of whether it will work at a given capacity. If we want to find the answer in a range `[0,M]` then we can apply the test at `M/2` and if it works then we recurse in the lower half and if it does not work then we recurse in the upper half. In this way we can come up with a binary search.\\r\n\\r\n# Approach\\r\n<!-- Describe your approach to solving the problem. -->\\r\nTo create the test described above we need to write a function `bool possible(int capacity, int days, vector<int>&weights)` which will return `true` if it is possible and `false` if it is not possible to work with `capacity`. We will use this for binary search as described previously.\\r\n\\r\n\\r\n# Code\\r\n```\\r\nclass Solution {\\r\npublic:\\r\n    bool possible(int capacity, int days, vector<int>&weights)\\r\n    {\\r\n        int n=weights.size(), i=0, ctr=0;\\r\n        while(i<n)\\r\n        {\\r\n            if (weights[i]>capacity) return false;\\r\n            int cur = 0;\\r\n            while(i<n && cur+weights[i]<=capacity)\\r\n            {\\r\n                cur += weights[i];\\r\n                i++;\\r\n            }\\r\n            ctr ++;\\r\n        }\\r\n        return (ctr<=days);\\r\n    }\\r\n    int shipWithinDays(vector<int>& weights, int days) \\r\n    {\\r\n        int lo=0, hi=INT_MAX;\\r\n        while (lo<=hi)\\r\n        {\\r\n            int mid = lo + (hi-lo)/2;\\r\n            if (possible(mid, days, weights)) hi = mid-1;\\r\n            else lo = mid+1;\\r\n        }\\r\n        return lo;\\r\n    }\\r\n};\\r\n```\\r\n\\r\n# Complexity\\r\n- Time complexity: $O(n \\log(M))$ where $M$ is the maximum possible value of `capacity`. It can be the maximum value of `weights` array but in our implementation we have taken it to be `INT_MAX` since the difference is trivial anyway (in log scale).\\r\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\n\\r\n- Space complexity: $O(1)$\\r\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\n","creationDate":1677034577}}},{"id":"3212716","title":"No DFS, No DP, Just Bitmask + simple counting","url":"/discuss/topic/3212716/no-dfs-no-dp-just-bitmask-simple-counting","questionTitle":"Count the Number of Square-Free Subsets","post":{"creationDate":1676954530},"post_data":{"id":3212716,"title":"No DFS, No DP, Just Bitmask + simple counting","solutionTags":[{"name":"C++"},{"name":"Bitmask"}],"post":{"id":5025121,"content":"We just count all valid bitmasks.\n```\nclass Solution {\npublic:\n    int mod = 1000000007;\n    vector<int> primes = vector<int>{2,3,5,7,11,13,17,19,23,29};\n    int getMask(int n)\n    {\n        if (n==1) return 0;\n        int mask = 0;\n        for (int i=0; i<primes.size();i++)\n        {\n            int ctr = 0;\n            while (n%primes[i]==0)\n            {\n                n /= primes[i];\n                ctr ++;\n            }\n            if (ctr>=2) return -1;\n            if(ctr) mask |= (1<<i);\n        }\n        return mask;\n    }\n    int squareFreeSubsets(vector<int>& nums) \n    {\n        unordered_map<long long,long long> H;\n        for (int n: nums)\n        {\n            unordered_map<long long,long long> Hcopy = H;\n            int mask = getMask(n);\n            if (mask==-1) continue;\n            for (auto [k,v]: Hcopy) if ((k & mask)==0) H[ (k|mask) ] = (H[k|mask]%mod + v%mod)%mod;\n            H[mask]++;\n        }\n        long long res = 0;\n        for (auto [k,v]: H) res += v;\n        return (int)(res%mod);\n    }\n};\n```","creationDate":1676954530}}},{"id":"3195707","title":"2 Heap solution with explaination","url":"/discuss/topic/3195707/2-heap-solution-with-explaination","questionTitle":"Put Marbles in Bags","post":{"creationDate":1676608064},"post_data":{"id":3195707,"title":"2 Heap solution with explaination","solutionTags":[{"name":"C++"},{"name":"Heap (Priority Queue)"}],"post":{"id":5002952,"content":"The question amounts to putting up `K-1` walls inside the `weights` array. The score is the sum of all the adjacent members of walls plus `weights[0]+weights[n-1]`.\nFor example consider the input `weights = [a,b,c,d,e,f,g,h,i], K=3` and if we put up walls like this: `a b c | d e f g |  h i`  then the score is `(a+c) + (d+g) + (h+i)` which can also be written as `(a+i) + (c+d) + (g+h)`.\n\nNow we want to find the difference between minimum and maximum scores. Notice that the first and last elements will always be part of any score. So, we need not consider them to calculate the difference. We can use a max-heap and a min-heap to store the sum of all adjacent pairs. In our example, this will be `a+b, b+c, c+d, d+e, e+f, f+g, g+h, h+i`. Once we have constructed both the heaps, the maximum score is the sum of `K-1` largest numbers from max heap and the minimum score is the sum of `K-1` smallest numbers from the min heap (plus the first and last, but we are ignoring them because they occur in both). Their difference gives us the answer.\n \n# Code\n```\nclass Solution {\npublic:\n    long long putMarbles(vector<int>& weights, int k) \n    {\n        int n = weights.size(), cur=weights[0];\n        if(k==1 || n==k) return 0;\n        priority_queue<int> max_pq;\n        priority_queue<int, vector<int>, greater<int>> min_pq;\n        for (int i=1; i<n; i++)\n        {\n            if (i>=2) cur -= weights[i-2];\n            cur += weights[i];\n            max_pq.push(cur);\n            min_pq.push(cur);\n\n        }\n        long long res = 0;\n        for (int i=0; i<k-1; i++)\n        {\n            res += max_pq.top();\n            res -= min_pq.top();\n            max_pq.pop();\n            min_pq.pop();\n        }\n        return res;\n    }\n};\n```\n\n# Complexity\nTC: $O(n + k\\log(n))$, SC: $O(n)$\n\nIf you like this post, please upvote it!","creationDate":1676608064}}},{"id":"3181314","title":"Clean HashMap solution","url":"/discuss/topic/3181314/clean-hashmap-solution","questionTitle":"Substring XOR Queries","post":{"creationDate":1676305201},"post_data":{"id":3181314,"title":"Clean HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":4984304,"content":"# Intuition\nThe idea is to store all (upto 32 digits long) binary substrings of `\"s\"` in a hashmap and then check the hashmap for each query.\n\nHere is the logic to enumerate all non-zero binary substrings of a string of length 1 to 32:\n```\nfor (int i=0; i<s.length(); i++)\n{\n    if (s[i]==\"0\") continue;\n    int num = 0;\n    for (int j=i; j<min(i+32,s.length()); j++) \n    {\n        num = (num<<1) + (s[j]-\"0\");\n        cout << \"substring:\" << s.substr(i,j-i+1) << \",value:\" << num << endl; \n    }\n}\n```\nWe just need to expand this logic to also consider the substring `\"0\"` and also to create a hashmap of `num: [i,j]` instead of just printing. \n\nThe hashmap stores the positions of first instance of a substring.\n\nWhile querying, we are looking for `query[0]^query[1]` because `a^c=b => c=a^b`. If we find it in hashmap we append its positions to result else append `[-1,-1]`.\n\n# Code\n```\nclass Solution {\npublic:\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \n    {\n        unordered_map<int, vector<int>> H;\n        for (int i=0; i<s.length(); i++)\n        {\n            if (s[i]==\"0\")\n            {\n                if (!H.count(0)) H[0]={i,i}; \n                continue;\n            }\n            int num = 0;\n            for (int j=i; j<min(i+32,(int)s.length()); j++) \n            {\n                num = (num<<1)+(s[j]-\"0\");\n                if (!H.count(num)) H[num] = {i,j};\n            }\n        }\n        vector<vector<int>> res;\n        for (auto &query: queries)\n        {\n            int val = query[0]^query[1];\n            if (H.count(val)) res.push_back(H[val]);\n            else res.push_back({-1,-1});\n        }\n        return res;\n    }\n};\n```\n\n# Complexity\nTC: $O(n+m)$, SC: $O(n+m)$ where $n=\\vert s \\vert$, $m=\\vert Q \\vert $\n\n### Note on limits\nActually we can also change the for loop to only consider substrings of upto 30 digits long: `for (int j=i; j<min(i+30,(int)s.length()); j++)`. This is because both `first` and `second` are in the range $[0,10^9]$, we know that $10^9$ in binary is 30 digits long. Hence their XOR can be at max 30 digits long ie their maximum value can be `2^{30}-1`.\n\nIn the current solution written above, the hashmap will also contain -ve numbers which is not useful for us but does us no harm. By changing 32 to 30 in the for loop, we can make hashmap a little bit smaller.\n","creationDate":1676305201}}},{"id":"3166951","title":"Multi Source BFS","url":"/discuss/topic/3166951/multi-source-bfs","questionTitle":"As Far from Land as Possible","post":{"creationDate":1676011851},"post_data":{"id":3166951,"title":"Multi Source BFS","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4965542,"content":"BFS is very appropriate here. We just need to check how many times we need to traverse to finish the queue of land cells. In one traversal, all adjacent members of the current queue get covered and converted to land cells. \n\n```\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) \n    {\n        int n = grid.size(), distance=-1;\n        queue<pair<int,int>> Q;\n        for (int i=0; i<n; i++) for (int j=0; j<n; j++)\n            if (grid[i][j]) Q.push({i,j});\n        if (Q.empty()||Q.size()==n*n) return -1;//All water or all land\n        vector<pair<int,int>> directions{{-1,0},{1,0},{0,-1},{0,1}};\n        while (!Q.empty())\n        {\n            for (int i=Q.size(); i>0; i--)\n            {\n                auto cell = Q.front();\n                Q.pop();\n                for (auto &dir: directions)\n                {\n                    int x = cell.first+dir.first;\n                    int y = cell.second+dir.second;\n                    if (x<0||x>=n||y<0||y>=n) continue;\n                    if (grid[x][y]==0)\n                    {\n                        grid[x][y] = 1;\n                        Q.push({x,y});\n                    }\n                }\n            }\n            distance++;\n        }\n        return distance;\n    }\n};\n```","creationDate":1676011851}}},{"id":"3165155","title":"HashSet for all letters","url":"/discuss/topic/3165155/hashset-for-all-letters","questionTitle":"Naming a Company","post":{"creationDate":1675963422},"post_data":{"id":3165155,"title":"HashSet for all letters","solutionTags":[{"name":"C++"},{"name":"Hash Table"}],"post":{"id":4963113,"content":"# Intuition\nConsider the example with all words from either `\"a\"` or `\"b\"`:\n```\nideas = [\"apple\",\"and\",\"alpha\",\"amaze\",\"aye\",\"aid\",\"bye\",\"bid\",\"bat\",\"beef\",\"brown\"]\n```\nBased on the starting letter and the suffix we can see this pattern:\n```\n\"a\": [\"pple\",\"nd\",\"lpha\",\"maze\",\"ye\",\"id\"]\n\"b\": [\"ye\",\"id\",\"at\",\"eef\",\"rown\"]\n```\nNotice that `\"ye\"` and `\"id\"` are present in both. These cannot be used for company names because for example suppose we use `\"aye\",\"bat\"` we will have `\"bye aat\"` as the company name but `\"bye\"` is present in original list of `ideas` hence not valid. So, we need to find the suffixes present in only one of the arrays:\n```\n\"a\": [\"pple\",\"lpha\",\"nd\",\"maze\"]\n\"b\": [\"at\",\"eef\",\"rown\"]\n```\nWe can choose 12 pairs from here and from them we will have 24 company names:\n```\ncompany_names = [\"aat bpple\", \"bpple aat\", \"aeef bpple\", \"bpple aeef\", \"arown bpple\", \"bpple arown\", \"aat blpha\", \"blpha aat\", \"aeef blpha\", \"blpha aeef\", \"arown blpha\", \"blpha arown\", \"aat bnd\", \"bnd aat\", \"aeef bnd\", \"bnd aeef\", \"arown bnd\", \"bnd arown\", \"aat bmaze\", \"bmaze aat\", \"aeef bmaze\", \"bmaze aeef\", \"arown bmaze\", \"bmaze arown\"]\n```\nHence answer for this example is 24.\n\n# Approach\nWe will use 26 HashSets to store suffixes for each alphabet. For each pair of alphabets, we will add their contribution as $2*n1*n2$ where $n1,n2$ are the suffixes from each alphabet not present in the other one.\n\n# Code\n```\nclass Solution {\npublic:\n    long long distinctNames(vector<string>& ideas) \n    {\n        long long res = 0;\n        vector<unordered_set<string>> ideaSet(26, unordered_set<string>{});\n        for(string idea: ideas) ideaSet[idea[0]-\"a\"].insert(idea.substr(1));\n        for (int i=0; i<26; i++)\n        {\n            for(int j=i+1; j<26; j++)\n            {\n                int common=0;\n                for(string idea: ideaSet[j]) common+=ideaSet[i].count(idea);\n                int n1 = ideaSet[i].size()-common, n2=ideaSet[j].size()-common;\n                res += 2LL*n1*n2;\n            }\n        }\n        return res;\n    }\n};\n```\n\n# Complexity\nWorst case time complexity is $O(nm)$ where $n$ is the number of words in `ideas`, $m$ is the maximum size of word in `ideas` .\nSpace complexity: $O(nm)$\n\n# Alternative solution\nWe can have slightly more efficient solution (same TC) if instead of storing suffixes we just maintain a 26x26 frequency table to check validity of name.\n```\nclass Solution {\npublic:\n    long long distinctNames(vector<string>& ideas) \n    {\n        long long res = 0;\n        unordered_set<string> ideaSet(ideas.begin(),ideas.end());\n        vector<vector<int>>freq_table(26,vector<int>(26,0));\n        for (string idea: ideas)\n        {\n            for(char ch=\"a\"; ch<=\"z\"; ch++)\n            {\n                string namePart = string(1,ch)+idea.substr(1);\n                if(!ideaSet.count(namePart))\n                    freq_table[idea[0]-\"a\"][ch-\"a\"]++;\n            }\n        }\n        for (int i=0; i<26; i++)\n            for (int j=i+1; j<26; j++)\n                res += 2LL*freq_table[i][j]*freq_table[j][i];\n        return res;\n    }\n};\n```","creationDate":1675963422}}},{"id":"3154206","title":"Sliding window + HashMap","url":"/discuss/topic/3154206/sliding-window-hashmap","questionTitle":"Subarrays with K Different Integers","post":{"creationDate":1675749131},"post_data":{"id":3154206,"title":"Sliding window + HashMap","solutionTags":[{"name":"C++"}],"post":{"id":4949070,"content":"We solve the problem of subarray with at most K distinct integers and use it for K and K-1 to get the answer.\n\n\n```\nclass Solution {\npublic:\n    int subarraysWithKDistinct(vector<int>& nums, int k)\n    {\n        return atMostK(nums,k)-atMostK(nums,k-1);\n    }\n    int atMostK(vector<int>& nums, int k) \n    {\n        int n = nums.size(), i=0, res=0;\n        unordered_map<int,int> H;\n        for (int j=0; j<n; j++)\n        {\n            H[nums[j]]++;\n            while(H.size()>k)\n            {\n                H[nums[i]]--;\n                if (H[nums[i]]==0) H.erase(nums[i]);\n                i++;\n            }\n            res += (j-i+1);\n        }\n        return res;\n    }\n};\n```","creationDate":1675749131}}},{"id":"3153941","title":"Reaching the best solution","url":"/discuss/topic/3153941/reaching-the-best-solution","questionTitle":"Fruit Into Baskets","post":{"creationDate":1675744650},"post_data":{"id":3153941,"title":"Reaching the best solution","solutionTags":[{"name":"C++"}],"post":{"id":4948702,"content":"We can immediately think of a brute-force $O(n^3)$ solution by checking all subarrays:\n```\nclass Solution {\npublic:\n    bool valid(vector<int>&fruits, int i, int j)\n    {\n        unordered_set<int> unq_fruits;\n        for(int k=i; k<=j; k++) unq_fruits.insert(fruits[k]);\n        return (unq_fruits.size()<=2);\n    }\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0;\n        if(n==1) return 1;\n        for (int i=0; i<n; i++) for (int j=i+1; j<n; j++)\n            if (valid(fruits,i,j)) res=max(res,j-i+1);\n        return res;\n    }\n};\n```\nThis will give us TLE. We can improve it to $O(n^2)$ by noticing that we do not need to check all subarrays. For any starting index, we only extend a subarray to the right as long as it is valid subarray.\n```\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0;\n        if(n==1) return 1;\n        for (int i=0; i<n; i++)\n        {\n            int j=i;\n            unordered_set<int> unq_fruits;\n            while (j<n)\n            {\n                if (!unq_fruits.count(fruits[j]) && unq_fruits.size()==2) break;\n                unq_fruits.insert(fruits[j]);\n                j++;\n            }\n            res = max(res, j-i);\n        }\n        return res;\n    }\n};\n```\nThis also gives us TLE. By now we must realize that HashSet will not be enough, we are going to need HashMap. The crucial use of HashMap is we can know exactly at what index the subarray becomes valid.\n\n```\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0, i=0;\n        if(n==1) return 1;\n        unordered_map<int,int> H;\n        for (int j=0; j<n; j++)\n        {\n            H[fruits[j]]++;\n            while(i<n && H.size()>2)\n            {\n                H[fruits[i]]--;\n                if (H[fruits[i]]==0) H.erase(fruits[i]);\n                i++;\n            }\n            res = max(res, j-i+1);\n        }\n        return res;\n    }\n};\n```\nThis is $O(n)$ solution and hence AC. However we can still do a minor improvement: We need not check all valid subarrays, only subarrays longer than the longest valid one we have seen earlier. In this solution, we lose track of the exact `(i,j)` that gives us the answer but the length is what we need. This is still $O(n)$.\n```\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0, i=0,j;\n        if(n==1) return 1;\n        unordered_map<int,int> H;\n        for (j=0; j<n; j++)\n        {\n            H[fruits[j]]++;\n            if(i<n && H.size()>2)\n            {\n                H[fruits[i]]--;\n                if (H[fruits[i]]==0) H.erase(fruits[i]);\n                i++;\n            }\n        }\n        return (j-i);\n    }\n};\n```","creationDate":1675744650}}},{"id":"3134605","title":"Easy Method","url":"/discuss/topic/3134605/easy-method","questionTitle":"Zigzag Conversion","post":{"creationDate":1675402140},"post_data":{"id":3134605,"title":"Easy Method","solutionTags":[{"name":"C++"}],"post":{"id":4923524,"content":"We only need to notice that the row number for any character is decided by its modulus wrt $m=2*|s|-2$. This can be easily observed once you notice that the pattern starts repeating after it reaches the top row after one zigzag. Hence $m$ is the length of one zigzag. Next we need to check if each position is coming in the downward phase or the upward phase of zigzag and accordingly update that row.\n\n```\nclass Solution {\npublic:\n    string convert(string s, int numRows) \n    {\n        if (numRows==1) return s;\n        int m = 2*numRows - 2;\n        vector<string> rows(numRows, \"\");\n        for (int i=0; i<s.length(); i++)\n        {\n            int r = i%m;\n            if (r<numRows) rows[r].push_back(s[i]);\n            else rows[m-r].push_back(s[i]);\n        }\n        string res = \"\";\n        for (string r: rows) res+=r;\n        return res;\n    }\n};\n```\n\nTime complexity: $O(n)$\n","creationDate":1675402140}}},{"id":"3106735","title":"Word Break extension (DP)","url":"/discuss/topic/3106735/word-break-extension-dp","questionTitle":"Word Break II","post":{"creationDate":1674847049},"post_data":{"id":3106735,"title":"Word Break extension (DP)","solutionTags":[{"name":"C++"}],"post":{"id":4887032,"content":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is from [Word Break](https://leetcode.com/problems/word-break). Basically we check at each position, if there is a valid word from any previous position. Reproducing my solution for Word Break below:\n```\nbool wordBreak(string s, vector<string>& words) \n{\n    unordered_set<string> wordSet(words.begin(),words.end());\n    int n = s.length();\n    vector<bool> valid(n+1, false);\n    valid[0] = true;\n    for (int j=1; j<=n; j++)\n        for (int i=0; i<j && !valid[j]; i++)\n            valid[j] = valid[i] && wordSet.count(s.substr(i,j-i));\n    return valid[n];\n}\n```\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInstead of a 1-D boolean `valid` array, here we will maintain a 2-D string array `A`. `A[i]` will have all valid \"sentences\" for `s[0:i]`. `A[0]` is a single word sentence (placeholder *). To find `A[j]` we look for all previous `A[i]` for all `i` in `0<=i<j` and if we find any sentence in `A[i]` then `A[j]` will have that sentence added with the word `s.substr(i,j-i)`. Finally we get rid of the placeholder and first space character in each sentence of `A[n]` to get the answer.\n\n\n\n# Code\n```\nclass Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& words) \n    {\n        unordered_set<string> wordSet(words.begin(),words.end());\n        int n = s.length();\n        vector<vector<string>> A(n+1,vector<string>{});\n        A[0] = {\"*\"};\n        for (int j=1; j<=n; j++)\n            for (int i=0; i<j; i++)\n                if (A[i].size()>0 && wordSet.count(s.substr(i,j-i)))\n                    for (string w: A[i])\n                        A[j].push_back(w+\" \"+s.substr(i,j-i));\n        auto res = A[n];\n        for (string &s: res) s = s.substr(2);\n        return res;\n    }\n};\n```\n\nRelated:\nhttps://leetcode.com/problems/concatenated-words/solutions/3106355/","creationDate":1674847049}}},{"id":"3106355","title":"Word Break extension (DP)","url":"/discuss/topic/3106355/word-break-extension-dp","questionTitle":"Concatenated Words","post":{"creationDate":1674841449},"post_data":{"id":3106355,"title":"Word Break extension (DP)","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4886580,"content":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is from [Word Break](https://leetcode.com/problems/word-break). Basically we check at each position, if there is a valid word from any previous position. Reproducing my solution for Word Break below:\n```\nbool wordBreak(string s, vector<string>& words) \n{\n    unordered_set<string> wordSet(words.begin(),words.end());\n    int n = s.length();\n    vector<bool> valid(n+1, false);\n    valid[0] = true;\n    for (int j=1; j<=n; j++)\n        for (int i=0; i<j && !valid[j]; i++)\n            valid[j] = valid[i] && wordSet.count(s.substr(i,j-i));\n    return valid[n];\n}\n```\n# Approach\n<!-- Describe your approach to solving the problem. -->\nWe just repeat Word Break for each word with all the other words.\n\n# Complexity\n- Time complexity: $O(N*M^3)$ where N is size of `words` array and `M` is the length of longest word. $N*M^2$ can be seen clearly from the `for` loops in code below. Extra `M` term is for string hashing.\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $O(N*M)$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \n    {\n        unordered_set<string> wordSet(words.begin(),words.end());\n        vector<string> res;\n        for (string word: words)\n        {\n            wordSet.erase(word);\n            int n = word.length();\n            vector<bool> valid(n+1, false);\n            valid[0] = true;\n            for (int j=1; j<=n; j++)\n                for (int i=0; i<j && !valid[j]; i++)\n                    valid[j] = valid[i] && wordSet.count(word.substr(i,j-i));\n            if (valid[n]) res.push_back(word);\n            wordSet.insert(word);\n        }\n        return res;        \n    }\n};\n```","creationDate":1674841449}}},{"id":"3055690","title":"Cumulative Sum","url":"/discuss/topic/3055690/cumulative-sum","questionTitle":"Increment Submatrices by One","post":{"creationDate":1673806047},"post_data":{"id":3055690,"title":"Cumulative Sum","solutionTags":[{"name":"C++"}],"post":{"id":4818416,"content":"# Intuition\nWe will maintain a matrix where each update is `O(1)` in time. At the end, we will use cumulative sum method to get final output.\n\n# Approach\nLet us first solve the [1-D version of the problem](https://leetcode.com/problems/range-addition/). Also availabe [here](https://leetcode.ca/all/370.html). I will give a brief overview.\nProblem is given length of array N starting with all zeros and some update queries of format `(left,right,increment)`, return the final array.\n```\nInput: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]\n```\nA naive way would be to update from left to right for each query:\n```\nvector<int> solve(int n, vector<vector<int>> updates)\n{\n    vector<int> A(n,0);\n    for (auto &query: updates)\n    {\n        int left = query[0], right = query[1], increment = query[2];\n        for (int i=left; i<=right; i++) A[i]+=increment;\n    }\n    return A;\n}\n```\nHere is a smarter way to do this: we just do `+increment` at `left` and `-increment` at `right+1` and finally return the cumulative sum array. We will need array of length `N+1` this time.\n```\nvector<int> solve(int n, vector<vector<int>> updates)\n{\n    vector<int> A(n+1,0);\n    for (auto &query: updates)\n    {\n        int left = query[0], right = query[1], increment = query[2];\n        A[left]+=increment;\n        A[right+1]-=increment\n    }\n    for (int i=1; i<=n; i++) A[i]+=A[i-1];\n    A.pop_back(); // we want only first n items. A[n] is always zero\n    return A;\n}\n```\nYou can see that the first method is $O(Q*N)$ and second method is $O(Q+N)$ where `N` is size of array and `Q` is number of update queries.\n\nLet us extend this logic to our problem.\nHere we will do the following updates for each update query. \n```\nM[r1][c1]++;\nM[r2+1][c1]--;\nM[r1][c2+1]--;\nM[r2+1][c2+1]++;\n```\nThe reason we need to do like this is because here we will be taking a 2-D cumulative sum by which we mean $res[i][j] = \\sum_{ii,jj} M[ii][jj]$ where $0<=ii<=i$ and $0<=jj<=j$\n\n\n# Complexity\n- Time complexity: $O(Q + N^2)$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $O(N^2)$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \n    {\n        vector<vector<int>> M = vector<vector<int>>(n+1, vector<int>(n+1,0));\n        for (auto &q: queries)\n        {\n            int r1=q[0], c1=q[1], r2=q[2], c2=q[3];\n            M[r1][c1]++;\n            M[r2+1][c1]--;\n            M[r1][c2+1]--;\n            M[r2+1][c2+1]++;\n        }\n        // Use this to print update matrix. You can check manually that the 2-D cumulative sum of this gives the answer\n        // for (auto &v: M){for(int k: v)cout<<k<<\",\";cout<<endl;} \n        vector<vector<int>> res = vector<vector<int>>(n, vector<int>(n,0));\n        res[0][0] = M[0][0];\n        for (int i=1; i<n; i++) res[i][0]=res[i-1][0]+M[i][0];\n        for (int j=1; j<n; j++) res[0][j]=res[0][j-1]+M[0][j];\n        for (int i=1; i<n; i++) for (int j=1; j<n; j++)\n            res[i][j] = -res[i-1][j-1]+res[i][j-1]+res[i-1][j]+M[i][j];\n        return res;\n    }\n};\n```","creationDate":1673806047}}},{"id":"3006919","title":"Monotonic Stack + DP","url":"/discuss/topic/3006919/monotonic-stack-dp","questionTitle":"Sum of Subarray Minimums","post":{"creationDate":1672987718},"post_data":{"id":3006919,"title":"Monotonic Stack + DP","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"},{"name":"Monotonic Stack"}],"post":{"id":4754541,"content":"# Intuition + Approach\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe intuition is that while traversing, we will maintain a 1-D DP array such that\n```\ndp[i] = f(0,i) + f(1,i) + f(2,i) + ... + f(i,i)\n```\nwhere \n```\nf(j,i) = Minimum from indices j to i (inclusive)\n```\n\nOnce we are done, we can add the `dp` array to get our answer.\n\n## Example\n```\narr = [8,6,3,5,4,9,2]\n```\nFor this example, we want that after we are done, the DP should look like:\n```\ndp = [8,12,9,14,17,26,14]\n```\nWe can see that how this matches our expectation:\n```\ndp[0] = 8\ndp[1] = 6+6\ndp[2] = 3+3+3\ndp[3] = 3+3+3+5\ndp[4] = 3+3+3+4+4\ndp[5] = 3+3+3+4+4+9\ndp[6] = 2+2+2+2+2+2+2\n```\nAs expected we can sum the `dp` array to get our answer 100.\n\n## How to create this DP array\nWe will use a monotonic stack (MS) for this. The basic setting for a MS is:\n```\nstack<int> stk;\nfor (int i=0; i<n; i++)\n{\n    while (!stk).empty() && stk.top()>=A[i]) stk.pop();\n    stk.push(A[i]);\n}\n```\nHere we will store the indices instead of the values. For each iteration in `i`, once we are done withe the popping, we can create `dp[i]` as follows:\n- If the stack is empty, it means the current element is the smallest of all elements in `(0,i)` range. Hence, `dp[i] = A[i]*(i+1)` corresponding to ranges `(0,i)`, `(1,i)`, `(2,i)`, ...., `(i,i)`.\n\n- If the stack is not empty and the top of the stack is `j`, then, for the ranges `(0,i)`, `(1,i)`, `(2,i)`, ..., `(j,i)`, the minimum element is stored in `dp[j]` (their sum) and for the ranges `(j+1,i)`, `(j+2,i)`, ..., `(i,i)`, the minimum element is `A[i]`. Hence, `dp[i] = dp[j] + A[i]*(i-j)`\n\n# Complexity\n- Time complexity: $O(n)$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $O(n)$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\n#define ll long long int\nclass Solution {\npublic:\n    int sumSubarrayMins(vector<int>& arr) \n    {\n        int n = arr.size(), mod=1000000007;\n        ll res = 0;\n        vector<ll> dp(n,-1);\n        stack<int> stk;\n        for (int i=0; i<n; i++)\n        {\n            while (!stk.empty() && arr[i]<=arr[stk.top()]) stk.pop();\n            if (!stk.empty())\n            {\n                int j = stk.top();\n                dp[i] = dp[j] + arr[i]*(i-j);\n            } \n            else dp[i] = arr[i]*(i+1);\n            stk.push(i);\n        }\n        for (int x: dp) res+=x;\n        return (int)(res%mod);\n    }\n};\n```","creationDate":1672987718}}},{"id":"3004894","title":"Intuitive C++ solution","url":"/discuss/topic/3004894/intuitive-c-solution","questionTitle":"Day of the Year","post":{"creationDate":1672954936},"post_data":{"id":3004894,"title":"Intuitive C++ solution","solutionTags":[{"name":"C++"}],"post":{"id":4751778,"content":"Make sure to take care of [leap year rule](https://www.mathsisfun.com/leap-years.html).\nExamples of leap years: 1992,1996,2000,2004,..,2096,2104\n\n# Code\n```\nclass Solution {\npublic:\n    int dayOfYear(string date) {\n        int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\n        int Y=stoi(date.substr(0,4)), M=stoi(date.substr(5,2)), D=stoi(date.substr(8,2));\n        if ((Y%4==0 && Y%100>0) || (Y%400==0)) days[1]=29;\n        int ctr=0;\n        for (int m=0;m<M-1;m++) ctr+=days[m];\n        ctr+=D;\n        return ctr;\n    }\n};\n```","creationDate":1672954936}}},{"id":"2966382","title":"Monotonic stack solution explained","url":"/discuss/topic/2966382/monotonic-stack-solution-explained","questionTitle":"Longest Absolute File Path","post":{"creationDate":1672301744},"post_data":{"id":2966382,"title":"Monotonic stack solution explained","solutionTags":[{"name":"C++"},{"name":"Monotonic Stack"}],"post":{"id":4702329,"content":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nMonotonic stack will be very useful here because we need to keep track of length of directory at current depth.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nWe will maintain the stack of `(depth, length of path)` and for each entry, we will keep popping from stack till we are at the correct depth.\nExample 1:\n```\ndir: [(0,3)]\n\tsubdir1: [(0,3)(1,11)]\n\tsubdir2: [(0,3)(1,11)]\n\t\tfile.ext: [(0,3)(1,11)(2,20)]\n```\nExample 2:\n```\ndir: [(0,3)]\n\tsubdir1: [(0,3)(1,11)]\n\t\tfile1.ext: [(0,3)(1,11)(2,21)]\n\t\tsubsubdir1: [(0,3)(1,11)(2,22)]\n\tsubdir2: [(0,3)(1,11)]\n\t\tsubsubdir2: [(0,3)(1,11)(2,22)]\n\t\t\tfile2.ext: [(0,3)(1,11)(2,22)(3,32)]\n```\n# Complexity\n- Time complexity: $$O(n)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(n)$$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\npublic:\n    int lengthLongestPath(string input) \n    {\n        stringstream ss(input);\n        string line;\n        vector<string> lines;\n        while (getline(ss, line, \"\\\n\")) lines.push_back(line);\n        stack<pair<int,int>> stk;\n        int res=0;\n        for (auto &line: lines)\n        {\n            int tabs=0;\n            while (line[tabs]==\"\t\") tabs++;\n            while (!stk.empty() && tabs<=stk.top().first) stk.pop();\n            int cur = (stk.empty() ? line.length() : stk.top().second+1+line.length()-tabs);\n            stk.push({tabs, cur});\n            if (find(line.begin(),line.end(),\".\")!=line.end()) res = max(res,cur);\n        }\n        return res;\n    }\n};\n```","creationDate":1672301744}}},{"id":"2930804","title":"Monotonic stack","url":"/discuss/topic/2930804/monotonic-stack","questionTitle":"Daily Temperatures","post":{"creationDate":1671513976},"post_data":{"id":2930804,"title":"Monotonic stack","solutionTags":[{"name":"C++"},{"name":"Monotonic Stack"}],"post":{"id":4656313,"content":"# Intuition\nThe idea is to maintain a montonically decreasing stack of temperatures. As soon as you see a value greater than the stack top, you have found the answer for the numbers at stack top which have value lower than current value.\n\n# Approach\nWe will use a monotonically decreasing stack. When we see a value smaller than stack top, just add it to the stack. But if we see a value higher than the stack top then we will update our answer for the stack top and pop from stack. We will keep doing this as long as current value is higher than stack top.\n\n# Complexity\n- Time complexity:\nO(N) where N is the number of days.\n- Space complexity:\nO(N) because stack size could go up to the number of days N.\n\n# Code\n```\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) \n    {\n        int n = temperatures.size();\n        stack<pair<int,int>> stk;\n        vector<int> res(n, 0);\n        for (int i=0; i<n; i++)\n        {\n            while (!stk.empty() && temperatures[i]>stk.top().first)\n            {\n                res[stk.top().second] = i-stk.top().second;\n                stk.pop();\n            }\n            stk.push({temperatures[i],i});\n        }\n        return res;\n    }\n};\n```","creationDate":1671513976}}},{"id":"2930673","title":"DFS + BFS solutions","url":"/discuss/topic/2930673/dfs-bfs-solutions","questionTitle":"Keys and Rooms","post":{"creationDate":1671512189},"post_data":{"id":2930673,"title":"DFS + BFS solutions","solutionTags":[{"name":"C++"},{"name":"Depth-First Search"},{"name":"Breadth-First Search"},{"name":"Graph"}],"post":{"id":4656152,"content":"# Intuition\nThis is a straightforward graph traversal problem.\n# Approach\nWe can do a simple BFS or DFS traversal to solve this.\n# Complexity\n- Time complexity:\nO(V) where V is the number of rooms\n- Space complexity:\nO(V) where V is the number of rooms\n# Code\n## BFS solution\n```\nclass Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        vector<bool> visited = vector<bool>(n,false);\n        queue<int> Q;\n        Q.push(0);\n        while (!Q.empty())\n        {\n            for (int i=Q.size(); i>0; i--)\n            {\n                int cur = Q.front();\n                Q.pop();\n                visited[cur] = true;\n                for (int adj: rooms[cur]) if (!visited[adj]) Q.push(adj);\n            }\n        }\n        for (bool v: visited) if (!v) return false;\n        return true;\n    }\n};\n```\n## DFS solution\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<int>> &rooms, vector<bool>&visited, int u)\n    {\n        visited[u] = true;\n        for (int v: rooms[u]) if (!visited[v]) dfs(rooms,visited,v);\n    }\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        vector<bool> visited = vector<bool>(n,false);\n        dfs(rooms, visited, 0);\n        for (bool v: visited) if (!v) return false;\n        return true;\n    }\n};\n```","creationDate":1671512189}}},{"id":"2865494","title":"Hacky solution","url":"/discuss/topic/2865494/hacky-solution","questionTitle":"Human Traffic of Stadium","post":{"creationDate":1669880386},"post_data":{"id":2865494,"title":"Hacky solution","solutionTags":[],"post":{"id":4570559,"content":"\n```\nselect distinct st.id,visit_date,st.people from stadium st join\n(\n    select * from\n    (\n        select id,people from stadium where people >= 100\n    ) as T1\n    inner join\n    (\n        select (id-1) as id2, people as people2 from stadium\n    ) as T2\n    inner join\n    (\n        select (id-2) as id3, people as people3 from stadium\n    ) as T3\n    on \n    T1.id = T2.id2 and T1.id=T3.id3\n    where people2>=100 and people3>=100\n) as T4\non st.id=T4.id or st.id-1=T4.id or st.id-2=T4.id\norder by visit_date asc\n```","creationDate":1669880386}}},{"id":"2865333","title":"Dense rank","url":"/discuss/topic/2865333/dense-rank","questionTitle":"Department Top Three Salaries","post":{"creationDate":1669877422},"post_data":{"id":2865333,"title":"Dense rank","solutionTags":[],"post":{"id":4570352,"content":"To understand this, you need to understand rank and dense rank.\n# Rank\nSay you have these `(name,salary)` rows in table T as\n```\n(A,100), (B,200), (C,200)\n```\nThen\nthe result of query\n```\nselect *,rank() over(order by salary desc) as sal_rank from T\n```\nwill be\n```\n(B,200,1),(C,200,1),(A,100,3)\n```\nie in case of clash same rank is given to all clashing and some ranks will be skipped.\n\nHowever `dense_rank` query\n```\nselect *,dense_rank() over(order by salary desc) as sal_rank from T\n```\nwill give following output\n```\n(B,200,1),(C,200,1),(A,100,2)\n```\nie same rank is given for clash similar to `rank()` but no ranks are skipped.\n\nOther trick to know is `partition by` inside the `over()` argument in `dense_rank()` function, just add `partition by dept` then, the ranks will be for people having same value of `dept`.\n\n# SQL code:\n\n```\nselect department,employee,salary from (\nselect *, dense_rank() over (partition by department order by salary desc) as sal_rank from \n(select E.name as employee,D.name as department,E.salary from employee E inner join department D on E.departmentid = D.id) as T1\n) as T2\nwhere T2.sal_rank<=3\n```","creationDate":1669877422}}},{"id":"2862161","title":"3D DP table","url":"/discuss/topic/2862161/3d-dp-table","questionTitle":"Paths in Matrix Whose Sum Is Divisible by K","post":{"creationDate":1669793681},"post_data":{"id":2862161,"title":"3D DP table","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4566216,"content":"Firstly a note regarding notation, I have replaced small k with capital K and I am using small k for indexing.\n# Algorithm:\nWe will create a DP table of shape `(M,N,K)` where `dp[i][j][k]` denotes number of ways to reach `(i,j)` coordinate with `sum%K==k`. At the end we will return `dp[M-1][N-1][0]`.\n\nNow for `(0,0)` there is one way to reach `dp[0][0]%K` but for other values of k, there is no way to achieve that sum.\n\n## Recurrence relation\n```\ndp[i][j][k] = A + B\n```\n\nwhere A is the number of ways to reach `(i,j)` via `(i,j-1)` and B is the number of ways to reach `(i,j)` via `(i-1,j)`\nNow we know that `A = dp[i][j-1][idx]`. We want to find this `idx`\nSuppose `grid[i][j]%K==x`. Then \n```\nidx = (K + k - x) % K\n```\nThis `idx` value is same even for `(i-1,j)`\n\n# C++ code:\n```\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>>& grid, int K) \n    {\n        int m=grid.size(), n=grid[0].size(), mod=1000000007;\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n,vector<int>(K,0)));\n        dp[0][0][grid[0][0]%K]++;\n        for (int i=0; i<m; i++)\n            for (int j=0; j<n; j++)\n                for (int k=0; k<K; k++)\n                {\n                    if (i==0 && j==0) continue;\n                    int a = ((j==0) ? 0 : dp[i][j-1][(K+k-grid[i][j]%K)%K] % mod);\n                    int b = ((i==0) ? 0 : dp[i-1][j][(K+k-grid[i][j]%K)%K] % mod);\n                    dp[i][j][k] = (a+b)%mod;\n                }\n        return dp[m-1][n-1][0];\n    }\n};\n```","creationDate":1669793681}}},{"id":"2849626","title":"[Explained + Example] DP (Knapsack)+ OOP Faster than 97%","url":"/discuss/topic/2849626/explained-example-dp-knapsack-oop-faster-than-97","questionTitle":"Maximum Profit in Job Scheduling","post":{"creationDate":1669455269},"post_data":{"id":2849626,"title":"[Explained + Example] DP (Knapsack)+ OOP Faster than 97%","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4549524,"content":"# Explanation\nWe sort the jobs by their ending times.\nNow as we traverse through the `jobs` array, we are going to apply a logic similar to Knapsack:\n- We maintain a `dp` array of `(endTime,maxProfitTillHere)` entities. We initialize it to `[(0,0)]`.\n- For each job, we have two options: (i) To do this job: in this case we need to find the `maxProfit` till the time before the `startTime` of current job. (ii) Not do this job: in the case we will have the same `maxProfit`till the previous `dp` member.\n- This is equivalent to the two options we have in a knapsack problem.\n\n# Example\n```\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n```\n\nThen sorted by endTime, we will have\n```\njobs = [(1,3,50),(2,4,10),(3,5,40),(3,6,70)]\n```\nInitialize dp:\n```\ndp = [(0,0)]`\n```\nAt i=0,\n```\noption_A = 0+50\noption_B = 0\n```\ndp gets appended.\n```\ndp = [(0,0),(3,50)]\n```\nAt i=1, Job = (2,4,10):\n```\noption_A = 0+10\noption_B = 50\n```\ndp remains same.\n```\ndp = [(0,0),(3,50)]\n```\nAt i=2, Job = (3,5,40):\n```\noption_A = 50+40\noption_B = 50\n```\ndp gets appended\n```\ndp = [(0,0),(3,50),(5,90)]\n```\nAt i=3, Job = (3,6,70):\n```\noption_A = 50+70\noption_B = 90\n```\ndp gets appended\n```\ndp = [(0,0),(3,50),(5,90),(6,120)]\n```\nFinally answer is 120.\n\nFor implementation we create a custom class `Job`. For the DP part, we just use `startTime=-1` for all timestamps as it does not matter.\n# C++ code:\n\n```\nclass Job\n{\n    public:\n    int startTime, endTime, profit;\n    Job(int s, int e, int p): startTime(s), endTime(e), profit(p) {}\n    bool operator <  (const Job &other_job)const{return endTime  < other_job.endTime;}\n    bool operator == (const Job &other_job)const{return endTime == other_job.endTime;}\n};\n\nclass Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) \n    {\n        int n = startTime.size();\n        vector<Job> jobs;\n        for (int i=0; i<n; i++)\n            jobs.push_back(Job(startTime[i],endTime[i],profit[i]));\n        sort(jobs.begin(),jobs.end());\n        \n        vector<Job> dp = vector<Job>{Job(-1,0,0)};\n        for (const Job &job: jobs)\n        {\n            auto itr = upper_bound(dp.begin(),dp.end(),Job(-1,job.startTime,-1));\n            int idx = itr-dp.begin()-1;\n            int opt_A = dp[idx].profit + job.profit;\n            int opt_B = dp.rbegin()->profit;\n            if (opt_A > opt_B)\n                dp.push_back(Job(-1,job.endTime, opt_A));\n        }\n        return dp.rbegin()->profit;\n    }\n};\n```","creationDate":1669455269}}},{"id":"2830288","title":"BFS","url":"/discuss/topic/2830288/bfs","questionTitle":"Is Graph Bipartite?","post":{"creationDate":1668867339},"post_data":{"id":2830288,"title":"BFS","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4523033,"content":"The idea is to check if a two-color coloring can be done to the graph. Colors={1,-1} and 0 denotes uncolored. Start with node 0 and traverse by BFS. Then for any other connected component repeat. To do this, we can run for all i from 0 to n and only start doing BFS if it is uncolored.\n\nNote that uncolored = unvisited.\n\n\n```\nclass Solution {\npublic:\n    bool isBipartite(vector<vector<int>>& graph) \n    {\n        int V = graph.size();\n        vector<int> colors = vector<int>(V,0);\n        queue<int> Q;\n\n        for (int i=0; i<V; i++)\n        {\n            if (colors[i]!=0) continue;\n            colors[i] = 1;\n            Q.push(i);\n            while(!Q.empty())\n            {\n                int u = Q.front();\n                Q.pop();\n                for (int v: graph[u])\n                {\n                    if (colors[v]==0)\n                    {\n                        colors[v] = -colors[u];\n                        Q.push(v);\n                    }\n                    else\n                        if (colors[v]==colors[u])\n                            return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```","creationDate":1668867339}}},{"id":"2822950","title":"Overlapping intervals expand idea from 1D","url":"/discuss/topic/2822950/overlapping-intervals-expand-idea-from-1d","questionTitle":"Rectangle Area","post":{"creationDate":1668665158},"post_data":{"id":2822950,"title":"Overlapping intervals expand idea from 1D","solutionTags":[{"name":"C++"}],"post":{"id":4513234,"content":"First let us solve the problem in 1D:\n**Given Two intervals (a1,a2) and (b1,b2) find if they are overlapping or not**\nWell, the answer is they are overlapping if \n```\nbool overlap = a1 < b2 && a2 > b1;\n```\n\n**What is the length of this overlap?**\nWell the length of overlap is\n```\nint L_overlap= min(a2,b2) - max(a1,b1);\n```\n\n**So, what is the total length**\n```\nint L1 = (a2-a1),   L2 = (b2-b1);\nint L_total = (overlap ? L1+L2-L_overlap : L1+L2);\n```\n\nNow we will expand this idea to 2D.\nThe only crucial difference is that the overlap happens only if the overlap condition is met in both X and Y directions.\n\nC++ code:\n```\nclass Solution {\npublic:\n    int area(int x1, int y1, int x2, int y2)\n    {\n        return (x2-x1) * (y2-y1);\n    }\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int A = area(ax1,ay1,ax2,ay2);\n        int B = area(bx1,by1,bx2,by2);        \n        bool overlap_x = bx1 < ax2 && bx2 > ax1;\n        bool overlap_y = by1 < ay2 && by2 > ay1;\n        if (!overlap_x || !overlap_y) return A + B;\n        int cx1 = max(ax1,bx1);\n        int cy1 = max(ay1,by1);\n        int cx2 = min(ax2,bx2);\n        int cy2 = min(ay2,by2);\n        int C = area(cx1,cy1,cx2,cy2);                \n        return A + B - C;\n    }\n};\n```","creationDate":1668665158}}},{"id":"2822056","title":"Recursivle solution with explanation","url":"/discuss/topic/2822056/recursivle-solution-with-explanation","questionTitle":"Count Complete Tree Nodes","post":{"creationDate":1668635378},"post_data":{"id":2822056,"title":"Recursivle solution with explanation","solutionTags":[{"name":"C++"},{"name":"Tree"},{"name":"Recursion"}],"post":{"id":4511990,"content":"First, let us define the concept of a \"full\" tree: a tree with no null nodes in the last level ie full upto its complete height.\n(Consider height of root as 0, level 1 as 1 etc)\n**IMP: What is the #(Nodes) in a full tree of height h**\nAns: `2^(h+1) - 1`\n\nNow, given that we have \"complete\" tree of height `h`, we can say that either the left subtree is a \"full\" tree of height `h-1` or the right subtree is a \"full\" tree of height `h-2`. \n\nIn the first case we have\n```\ncountNodes(root) = 2^h + countNodes(root->right)\n```\n(`2^h = 2^h - 1` for left subtree and `1` for root)\nand in the second case, we have\n\n```\ncountNodes(root) = 2^(h-1) + countNodes(root->left)\n```\n(`2^(h-1) = 2^(h-1) - 1` for right subtree and `1` for root)\n\nC++ code:\n```\nclass Solution {\npublic:\n    int height(TreeNode *root)\n    {\n        return root == NULL ? -1 : 1+height(root->left);\n    }\n    int countNodes(TreeNode* root) \n    {\n        if (!root) return 0;\n        int h = height(root);\n        if (h==0) return 1;\n        if (height(root->right)==h-1)\n            return (1<<h) + countNodes(root->right);\n        else\n            return (1<<h-1) + countNodes(root->left);\n        return -1;\n    }\n};\n```\n```\nTC=O((log n)^2)\n```\n","creationDate":1668635378}}},{"id":"2819522","title":"[Explained] Trie + DFS Clean C++ code","url":"/discuss/topic/2819522/explained-trie-dfs-clean-c-code","questionTitle":"Word Search II","post":{"creationDate":1668576290},"post_data":{"id":2819522,"title":"[Explained] Trie + DFS Clean C++ code","solutionTags":[{"name":"C++"},{"name":"Depth-First Search"},{"name":"Trie"}],"post":{"id":4508695,"content":"Step 1 is to build Trie. This should be simple enough if you have done [this](https://leetcode.com/problems/implement-trie-prefix-tree/).\n\nStep 2 is to do DFS and pass this Trie as an argument of DFS. In a simpler implemtation, you can pass the same trie that we constructed again and again and search from root using `hasPrefix` and `hasWord` to look for candidates but this will give you a TLE because it is traversing from the root node again and again. The more efficient way is to pass child trie in the recursive call, so we dont actually need `hasPrefix` or `hasWord`. Nevertheless I have left it as it helps us to understand Trie concept.\n\nYou might still get a TLE. Now, change the arguments `board` to pass only reference to avoid time of copying in memory for each recursive call. \n\nThis gives us an AC.\n\n```\n\nclass Trie\n{\n    public:\n    vector<Trie *> children = vector<Trie *>(26, NULL);\n    bool isEnd = false;\n    void insert(string word, int pos=0)\n    {\n        if (pos==word.length())\n        {\n            isEnd = true;\n            return;\n        }\n        int idx = word[pos]-\"a\";\n        if (children[idx]==NULL)\n            children[idx] = new Trie;\n        children[idx]->insert(word, pos+1);\n    }\n    bool hasPrefix(string prefix, int pos=0)\n    {\n        if (pos==prefix.length()) return true;\n        int idx = prefix[pos]-\"a\";\n        if (children[idx]==NULL) return false;\n        return children[idx]->hasPrefix(prefix, pos+1);\n    }\n    bool hasWord(string word, int pos=0)\n    {\n        if (pos==word.length()) return isEnd;\n        int idx = word[pos]-\"a\";\n        if (children[idx]==NULL) return false;\n        return children[idx]->hasWord(word, pos+1);\n    }\n};\n\nclass Solution {\npublic:\n    void dfs(vector<vector<char>> &board, int i, int j, int m, int n, Trie *trie, unordered_set<string>&res,string &curr)\n    {\n        if (board[i][j]==\"*\") return;\n        int idx = board[i][j]-\"a\";\n        Trie *child_trie = trie->children[idx];\n        if (child_trie==NULL) return;\n        curr.push_back(board[i][j]);\n        if (child_trie->isEnd) res.insert(curr);\n        board[i][j] = \"*\";\n        if (i-1>=0) dfs(board,i-1,j,m,n,child_trie,res,curr);\n        if (i+1<m)  dfs(board,i+1,j,m,n,child_trie,res,curr);\n        if (j-1>=0) dfs(board,i,j-1,m,n,child_trie,res,curr);\n        if (j+1<n)  dfs(board,i,j+1,m,n,child_trie,res,curr);\n        board[i][j] = \"a\"+idx;\n        curr.pop_back();\n    }\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) \n    {\n        Trie *trie = new Trie;\n        for (string word: words)\n            trie->insert(word);\n\n        // Code for testing Trie\n        // for (string w: vector<string>{\"oat\",\"oath\",\"oaths\",\"oas\",\"aoth\",\"eat\"})\n        //     cout << w << \" hasPrefix: \" << trie.hasPrefix(w) << \" hasWord: \" << trie.hasWord(w) << endl;\n\n        int m=board.size(), n=board[0].size();\n        unordered_set<string> res;\n        for (int i=0; i<m; i++)\n            for (int j=0; j<n; j++)\n            {\n                string cur=\"\";\n                dfs(board, i, j, m, n, trie, res, cur);\n            }\n        vector<string>resv;\n        for(string s: res) resv.push_back(s);\n        return resv;\n    }\n};\n```\n\nNote: My old code which gave TLE for large input can be found [here](https://leetcode.com/submissions/detail/844142181/). It is simpler in implementation but calls `hasPrefix` again and again which traverses from root everytime.","creationDate":1668576290}}},{"id":"2810978","title":"✅ ✅ ✅  One Liner","url":"/discuss/topic/2810978/one-liner","questionTitle":"Reverse Words in a String","post":{"creationDate":1668347210},"post_data":{"id":2810978,"title":"✅ ✅ ✅  One Liner","solutionTags":[{"name":"Python"}],"post":{"id":4497016,"content":"Python has stuff like `split`, `reversed` and `join` which lets us write a 1-liner.\n```\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n```","creationDate":1668347210}}},{"id":"2810955","title":"Min Heap","url":"/discuss/topic/2810955/min-heap","questionTitle":"Kth Largest Element in a Stream","post":{"creationDate":1668346642},"post_data":{"id":2810955,"title":"Min Heap","solutionTags":[{"name":"Heap (Priority Queue)"}],"post":{"id":4496982,"content":"Maintain the highest K elements in a min Heap. Then the root node is always the answer.\n```\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int k;\n    KthLargest(int k, vector<int>& nums): k(k)\n    {\n        for (int n: nums) pq.push(n);\n        while (pq.size()>k) pq.pop();\n    }\n    \n    int add(int val) \n    {\n        pq.push(val);\n        while(pq.size()>k) pq.pop();\n        return pq.top();\n    }\n};\n```","creationDate":1668346642}}},{"id":"2810670","title":"BFS + Min swaps to sort","url":"/discuss/topic/2810670/bfs-min-swaps-to-sort","questionTitle":"Minimum Number of Operations to Sort a Binary Tree by Level","post":{"creationDate":1668341117},"post_data":{"id":2810670,"title":"BFS + Min swaps to sort","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4496615,"content":"Use BFS to get nodes at each level. Then we need an algorithm to find minimum number of swaps to sort an array. I used [this reference](https://www.youtube.com/watch?v=kFe_LRWuZjE) for this part. The idea is simple: Traverse through sorted version of array and try to get back original array by swapping repeatedly.\n\n```\nclass Solution {\npublic:\n    int numSwaps(vector<int> &A)\n    {\n        int swaps = 0, n=A.size();\n        vector<pair<int,int>> vec;\n        for (int i=0; i<n; i++) vec.push_back({A[i],i});\n        sort(vec.begin(),vec.end());\n        for (int i=0; i<n; i++)\n        {\n            int value=vec[i].first, index=vec[i].second;\n            if (i!=index)\n            {\n                swaps++;\n                swap(vec[i], vec[index]);\n                i--;\n            }\n        }\n        return swaps;\n    }\n    int minimumOperations(TreeNode* root) \n    {\n        queue<TreeNode *>Q;\n        Q.push(root);\n        int ctr = 0;\n        while(!Q.empty())\n        {\n            vector<int> vals;\n            for (int i=Q.size(); i>0; i--)\n            {\n                TreeNode *u = Q.front();\n                Q.pop();\n                vals.push_back(u->val);\n                if (u->left) Q.push(u->left);\n                if (u->right) Q.push(u->right);\n            }\n            if (vals.size()<=1) continue;\n            ctr += numSwaps(vals);\n        }\n        return ctr;\n    }\n};\n```","creationDate":1668341117}}},{"id":"2805260","title":"O(1) space + 100% faster","url":"/discuss/topic/2805260/o1-space-100-faster","questionTitle":"Odd String Difference","post":{"creationDate":1668223437},"post_data":{"id":2805260,"title":"O(1) space + 100% faster","solutionTags":[{"name":"C++"}],"post":{"id":4488947,"content":"```\nclass Solution {\npublic:\n    string oddString(vector<string>& words) \n    {\n        int m=words.size(), n=words[0].length();\n        for(int j=1; j<n; j++)\n        {\n            int dA = words[0][j]-words[0][j-1];\n            int dB = words[1][j]-words[1][j-1];\n            if (dA!=dB)\n            {\n                int dC = words[2][j]-words[2][j-1];\n                return ((dC==dA) ? words[1] : words[0]);\n            }\n            // dA==dB\n            for (int i=2; i<m; i++)\n            {\n                int diff = words[i][j]-words[i][j-1];\n                if (diff!=dA) return words[i];\n            }\n        }\n        return \"\";\n    }\n};\n```","creationDate":1668223437}}},{"id":"2764996","title":"Just play the game!","url":"/discuss/topic/2764996/just-play-the-game","questionTitle":"Where Will the Ball Fall","post":{"creationDate":1667265982},"post_data":{"id":2764996,"title":"Just play the game!","solutionTags":[],"post":{"id":4434753,"content":"Just follow the rules and play the game.\n- If you get stuck on the left or right edge, return -1\n- If you get stuck in a V shape pattern return -1\n- If exit from the last row, return column index.\n\n**Well thats it. Now just play the game!**\n```\nclass Solution {\npublic:\n    int playGame(vector<vector<int>>&grid, int i, int j, int m, int n)\n    {\n        if (i==m) return j;\n        if (j<n-1 && grid[i][j]== 1 && grid[i][j+1]==-1) return -1;\n        if (j>0   && grid[i][j]==-1 && grid[i][j-1]== 1) return -1;\n        if (j==0 && grid[i][j] ==-1) return -1;\n        if (j==n-1 && grid[i][j]==1) return -1;\n        if (grid[i][j]==1) \n            return playGame(grid,i+1, j+1, m, n);\n        return playGame(grid,i+1,j-1,m,n);\n    }\n    \n    vector<int> findBall(vector<vector<int>>& grid) \n    {\n        int m=grid.size(), n=grid[0].size();\n        vector<int>res(n,0);\n        for (int j=0; j<n; ++j)\n            res[j] = playGame(grid,0,j,m,n);\n        return res;\n    }\n};\n```","creationDate":1667265982}}},{"id":"2743862","title":"C++ stack clean 10 line solution","url":"/discuss/topic/2743862/c-stack-clean-10-line-solution","questionTitle":"Valid Parentheses","post":{"creationDate":1666724722},"post_data":{"id":2743862,"title":"C++ stack clean 10 line solution","solutionTags":[],"post":{"id":4405907,"content":"```\nclass Solution {\npublic:\n    bool isValid(string s) \n    {\n        stack<char>stk;\n        unordered_map<char,char>map{{\"(\",\")\"},{\"{\",\"}\"},{\"[\",\"]\"}};\n        for (char ch: s)\n        {\n            if (map.count(ch)) stk.push(ch);\n            else\n            {\n                if (stk.empty() || map[stk.top()]!=ch)\n                    return false;\n                stk.pop();\n            }\n        }\n        return stk.empty();\n    }\n};\n```","creationDate":1666724722}}},{"id":"2743817","title":"Well explained solution in easy way","url":"/discuss/topic/2743817/well-explained-solution-in-easy-way","questionTitle":"Reverse Nodes in k-Group","post":{"creationDate":1666723573},"post_data":{"id":2743817,"title":"Well explained solution in easy way","solutionTags":[{"name":"C++"}],"post":{"id":4405847,"content":"Here is the code to reverse linked list:\n```\nListNode* reverse(ListNode* head) \n{\n\tListNode *curr=head, *prev=NULL, *upcoming;\n\twhile (curr)\n\t{\n\t\tupcoming = curr->next;\n\t\tcurr->next = prev;\n\t\tprev = curr;\n\t\tcurr = upcoming;\n\t}\n\treturn prev;\n}\n```\nCode is pretty much self-explanatory. Here is an example:\n```\nhead=1,2,3,NULL\n```\nAfter 1st iteration:\n```\nhead=1,NULL\nprev=1,NULL\ncurr=2,3,NULL\n```\nAfter 2nd iteration:\n```\nhead=1,NULL\nprev=2,1,NULL\ncurr=3,NULL\n```\nAfter 3rd iteration\n```\nhead=1,NULL\nprev=3,2,1,NULL\ncurr=NULL\n```\nNow it stops.\n\nNow to solve our question and inspired from above logic, we replace constraint in `while(curr)` so that it stops when we have done k iterations. For example\n\n```\nhead=1,2,3,4,5,NULL\nk=2\n```\nWhen while loop stops we will have\n```\nhead=1,NULL\nprev=2,1,NULL\ncurr=3,4,5,NULL\n```\n\nNow we need to check if the remaining part of LL `3,4,5,NULL` requires reversal or not.\nIf it does, then we add the reverse part of the remaining LL to `head` which is still at `1`. If not we add the remaining LL without reversal to `head`. Finally return `prev`.\n\nC++ code:\n\n```\nclass Solution {\npublic:\n    bool countK(ListNode *node, int k)\n    {\n        int i=0;\n        while (node && i<k)\n        {\n            node = node->next;\n            i++;\n        }\n        return (i==k);\n    }\n    ListNode* reverseKGroup(ListNode* head, int k) \n    {\n        ListNode *curr=head, *prev=NULL, *upcoming;\n        int i=0;\n        while (i<k)\n        {\n            upcoming = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = upcoming;\n            i++;\n        }\n        if (curr && countK(curr, k))\n            head->next = reverseKGroup(curr, k);\n        else\n            head->next = curr;\n        return prev;\n    }\n};\n```","creationDate":1666723573}}},{"id":"2743558","title":"Greedy Solution","url":"/discuss/topic/2743558/greedy-solution","questionTitle":"Partition Labels","post":{"creationDate":1666719041},"post_data":{"id":2743558,"title":"Greedy Solution","solutionTags":[],"post":{"id":4405486,"content":"Notice that it is sufficient if you get the first partition. Because the rest of the partitions can be obtained by recursively calling the same function for the remaining part of string.\n\nHere is the code to print the first parition (this is not the solution but this code will help you to understand).\n```\nvector<int> partitionLabels(string s) \n{\n\tint n=s.length(), j=n-1;\n\twhile (s[j]!=s[0]) j--;\n\tfor (int i=0; i<=j; i++)\n\t{\n\t\tint jj=n-1;\n\t\twhile (s[jj]!=s[i]) jj--;\n\t\tj = max(j,jj);\n\t}\n\tcout << s.substr(0,j+1) << endl;\n\treturn {};\n}\n```\nFor `s = ababcbacadefegdehijhklij`, it will print `ababcbaca`\nFor `s = defegdehijhklij` it will print `defegde`.\nFor `s = hijhklij` it will print `hijhklij` (same as s).\n\nThe way it works is that for each character in the partition we find the maximum index of its occurence. Then the paritition is equal to the maximum of these max-indexes.\n\nNow we just need to find the remaining partitions uising recursion for the remaining part of string.\n\nC++ code:\n\n```\nclass Solution {\npublic:\n    vector<int> partitionLabels(string s) \n    {\n        vector<int> res;\n        int n=s.length(), j=n-1;\n        while (s[j]!=s[0]) j--;\n        for (int i=0; i<=j; i++)\n        {\n            int jj=n-1;\n            while (s[jj]!=s[i]) jj--;\n            j = max(j,jj);\n        }\n        res.push_back(j+1);\n        if (j<s.length()-1)\n        {\n            for (int len: partitionLabels(s.substr(j+1,n)))\n                res.push_back(len);\n        }\n        return res;\n    }\n};\n```","creationDate":1666719041}}},{"id":"2743339","title":"C++ DP with explanation","url":"/discuss/topic/2743339/c-dp-with-explanation","questionTitle":"Palindromic Substrings","post":{"creationDate":1666715202},"post_data":{"id":2743339,"title":"C++ DP with explanation","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4405206,"content":"Maintain a boolean 2D matrix table to store palindome-ity. Specifically `dp[i][j]` denotes `s[i,..,j]` is a palindrome or not (i and j included). \nThe tricky part is that you have to traverse from Length = 1 to Length = n. For each length explore all possible starting positions for `i` and j then becomes `i+len-1`\nThe recurrence relation for palindrome-ity is\n```\ndp[i][j] =  (s[i]==s[j] && dp[i+1][j-1])\n```\nBasically it says if the outer two characters are same and the inside string is a palindrome then as a whole is a palindrome.\nHowever, there is no inner string for strings of length 1 and 2. Hence we have to modify:\n```\ndp[i][j] =  (s[i]==s[j] && (len<=2 || dp[i+1][j-1]))\n```\n\nC++ code:\n```\nclass Solution {\npublic:\n    int countSubstrings(string s) \n    {\n        int n = s.length(), ctr = 0;\n        vector<vector<bool>> dp(n, vector(n,false));\n        for (int len=1; len<=n; len++)\n        {\n            for (int i=0; i<=n-len; i++)\n            {\n                int j = i+len-1;\n                if (s[i]==s[j] && (len<=2 || dp[i+1][j-1]))\n                {\n                    dp[i][j] = true;\n                    ctr++;\n                }\n            }\n        }\n        return ctr;\n    }\n};\n```","creationDate":1666715202}}},{"id":"2743251","title":"Easy BFS","url":"/discuss/topic/2743251/easy-bfs","questionTitle":"Binary Tree Right Side View","post":{"creationDate":1666713849},"post_data":{"id":2743251,"title":"Easy BFS","solutionTags":[{"name":"Breadth-First Search"}],"post":{"id":4405096,"content":"```\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) \n    {\n        if (!root) return {};\n        vector<int>res;\n        queue<TreeNode *>Q;\n        Q.push(root);\n        while (!Q.empty())\n        {\n            int qsize = Q.size();\n            for (int i=0; i<qsize; i++)\n            {\n                root = Q.front();\n                Q.pop();\n                if (root->left) Q.push(root->left);\n                if(root->right) Q.push(root->right);\n            }\n            res.push_back(root->val);\n        }\n        return res;\n    }\n};\n```","creationDate":1666713849}}},{"id":"2742640","title":"Easy O(m*n)","url":"/discuss/topic/2742640/easy-omn","questionTitle":"Minimum Path Sum","post":{"creationDate":1666702323},"post_data":{"id":2742640,"title":"Easy O(m*n)","solutionTags":[{"name":"C++"}],"post":{"id":4404256,"content":"The top row and leftmost column can simply be computed.\nAfter that for any node, the answer can be either its upward neighbor + node value or its leftward neighbor + node value;\n```\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        int m=grid.size(), n=grid[0].size();\n        vector<vector<int>> sumgrid(m, vector<int>(n,0));\n        sumgrid[0][0] = grid[0][0];\n        for (int i=1; i<m; i++) \n            sumgrid[i][0] = sumgrid[i-1][0] + grid[i][0];\n        for (int j=1; j<n; j++)\n            sumgrid[0][j] = sumgrid[0][j-1] + grid[0][j];\n        for (int i=1; i<m; i++)\n            for (int j=1; j<n; j++)\n                sumgrid[i][j] = min(sumgrid[i-1][j],sumgrid[i][j-1]) + grid[i][j];\n        return sumgrid[m-1][n-1];\n    }\n};\n```","creationDate":1666702323}}},{"id":"2742578","title":"[100%] Easy DP","url":"/discuss/topic/2742578/100-easy-dp","questionTitle":"Unique Binary Search Trees","post":{"creationDate":1666701331},"post_data":{"id":2742578,"title":"[100%] Easy DP","solutionTags":[{"name":"Dynamic Programming"}],"post":{"id":4404179,"content":"Assume that you already know `numTrees(1), numTrees(2), numTrees(3),..., numTrees(n-1)` and want to calculate `numTrees(n)`.\nWe have `n` choices for root. For choice `root` as root let us calculate number of trees. Nodes `1,2,...,root-1` have to be in left subree and nodes `root+1,root+2,...,n` have to be in right subtree. \n\n**Number of trees with root `root` = (Number of trees that can be formed from nodes `1,2,...,root-1`) * (Number of trees that can be formed from nodes `root+1,root+2,...,n`)`**\n\nHence\n```\nnumTrees(n) with root = numTrees(root-1)+numTrees(n-root)`\n```\n\nC++ Code:\n```\nclass Solution {\npublic:\n    int numTrees(int n) \n    {\n        vector<int> dp(n+1,0);\n        dp[0] = 1;\n        for (int i=1; i<=n; i++)\n        {\n            int ctr = 0;\n            for (int root=1; root<=i; root++)\n                ctr += dp[root-1]*dp[i-root];\n            dp[i] = ctr;\n        }\n        return dp[n];\n    }\n};\n```\n```\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Unique Binary Search Trees.\nMemory Usage: 6 MB, less than 71.42% of C++ online submissions for Unique Binary Search Trees.\n```","creationDate":1666701331}}},{"id":"2742389","title":"C++ Stack 100%","url":"/discuss/topic/2742389/c-stack-100","questionTitle":"Decode String","post":{"creationDate":1666697807},"post_data":{"id":2742389,"title":"C++ Stack 100%","solutionTags":[{"name":"C++"}],"post":{"id":4403920,"content":"Example: `3[a2[c]]` \nAfter traversal we will have the stack `(\"\",3),(a,2)` and have the string `c` as the current string. \nFrom the stack we pop `num` and then `prevString`.\n```\ncurString = prevString + num*curString\n```\n \nC++ code:\n```\nclass Solution {\npublic:\n    string decodeString(string s) \n    {\n        string curString=\"\", curNum=\"\";\n        stack<string> stk;\n        for (char ch: s)\n        {\n            if (ch==\"[\")\n            {\n                stk.push(curString);\n                stk.push(curNum);\n                curString = \"\";\n                curNum = \"\";\n            }\n            else if (ch==\"]\")\n            {\n                int num = stoi(stk.top());\n                stk.pop();\n                string prevString = stk.top();\n                stk.pop();\n                string temp = prevString;\n                for (int i=0;i<num;i++) \n                    temp += curString;\n                curString = temp;\n            }\n            else if (isdigit(ch))\n                curNum += ch;\n            else\n                curString += ch;\n        }\n        return curString;\n    }\n};\n```","creationDate":1666697807}}},{"id":"2742171","title":"Easy BFS","url":"/discuss/topic/2742171/easy-bfs","questionTitle":"Rotting Oranges","post":{"creationDate":1666693697},"post_data":{"id":2742171,"title":"Easy BFS","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4403622,"content":"BFS is very appropriate here. We just need to check how many times we need to traverse to finish the queue. In one traversal, all adjacent members of the current queue get covered. At the end we also check thre is a fresh orange, if yes we return -1 and if not we return the answer.\n- Add all cells with rotten oranges in Queue.\n- Run BFS in the queue.\n- Count the number of times we need to traverse.\n- After we are done, check for any fresh remaining orange.\n\nC++ Code:\n\n```\nclass Solution {\npublic:\n    bool notdone(vector<vector<int>> &grid)\n    {\n        for (auto row: grid)\n            for (int cell: row)\n                if (cell==1)\n                    return true;\n        return false;\n    }\n\n    int orangesRotting(vector<vector<int>>& grid) \n    {\n        if (!notdone(grid)) return 0;\n        int m=grid.size(), n=grid[0].size(), ctr=0;\n        vector<pair<int,int>> dirs {{-1,0},{1,0},{0,-1},{0,1}};\n        queue<pair<int,int>> Q;\n        for (int i=0; i<m; i++)\n            for (int j=0; j<n; j++)\n                if (grid[i][j]==2)\n                    Q.push({i,j});\n        while (!Q.empty())\n        {\n            int qsize = Q.size();\n            for (int i=0; i<qsize; i++)\n            {\n                auto point = Q.front();\n                Q.pop();\n                for (auto dir: dirs)\n                {\n                    int x = point.first + dir.first;\n                    int y = point.second + dir.second;\n                    if (x<0 || x>=m || y<0 || y>=n || grid[x][y]!=1)\n                        continue;\n                    grid[x][y] = 2;\n                    Q.push({x,y});\n                }\n            }\n            ctr++;\n        }\n        if (notdone(grid)) return -1;\n        return ctr-1;\n    }\n};\n```","creationDate":1666693697}}},{"id":"2741753","title":"Easy DFS","url":"/discuss/topic/2741753/easy-dfs","questionTitle":"Path Sum III","post":{"creationDate":1666686010},"post_data":{"id":2741753,"title":"Easy DFS","solutionTags":[{"name":"Depth-First Search"}],"post":{"id":4403084,"content":"The idea is that any valid path will have a starting node and go down thereafter. So, we start from root and go down while checking if there is valid path starting from that node.\nSo, for the tree in the question example 1:\n```\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n```\nWe will check paths \n```\n[10],[10,5],[10,5,3],[10,5,3,3],[10,5,3,-2],[10,5,2],[10,5,2,1],[10,-3],[10,-3,11]\n```\nThen we will check paths\n```\n[5],[5,3],[5,3,3],[5,3,-2],[5,2],[5,2,1]\n```\nand so on.\n\nC++ code:\n```\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int targetSum) \n    {\n        if (!root) return 0;\n        return sumUp(root, 0, targetSum) + pathSum(root->left, targetSum) + pathSum(root->right, targetSum);\n    }\n    int sumUp(TreeNode *root, long long curr, int target)\n    {\n        if (!root) return 0;\n        curr += root->val;\n        return (curr==target) + sumUp(root->left, curr, target) + sumUp(root->right,curr,target);\n    }\n};\n```","creationDate":1666686010}}},{"id":"2741593","title":"Iterative binary search","url":"/discuss/topic/2741593/iterative-binary-search","questionTitle":"Find Minimum in Rotated Sorted Array","post":{"creationDate":1666682871},"post_data":{"id":2741593,"title":"Iterative binary search","solutionTags":[{"name":"C++"}],"post":{"id":4402874,"content":"Notice that to verify if an array element is minimum or not, it is sufficient to verify that it is smaller than both its neighbors (with rotation).ie\n```\nprev = (mid==0) ? n-1 : mid-1\nnext = (mid==n-1) ? 0 : mid+1\nA[mid]<=A[prev] and A[mid]<=A[next]\n```\nWe want to find an index `mid` in the range `[0,n)` that satisfies this condition. We use binary search for this.\n\n```\nint findMin(vector<int>& nums) \n{\n\tint n=nums.size(), lo=0, hi=n-1, mid;\n\twhile (lo<=hi)\n\t{\n\t\tmid = lo + (hi-lo)/2;\n\t\tint prev = (mid-1+n)%n, next = (mid+1)%n;\n\t\tif (nums[mid]<=nums[prev] && nums[mid]<=nums[next])\n\t\t\tbreak;\n\t\telse if (nums[mid] <= nums[hi])\n\t\t\thi = mid-1;\n\t\telse\n\t\t\tlo = mid+1; // nums[0...mid] subarray is sorted\n\t}\n\treturn nums[mid];\n}\n```","creationDate":1666682871}}},{"id":"2730302","title":"[Easy] One liner","url":"/discuss/topic/2730302/easy-one-liner","questionTitle":"Factorial Trailing Zeroes","post":{"creationDate":1666380488},"post_data":{"id":2730302,"title":"[Easy] One liner","solutionTags":[{"name":"C++"}],"post":{"id":4387631,"content":"You should notice that the number of zeros is bounded by the number of factors of 5 and its powers because 2 will have always more. So we just count the number of factors of each power of 5 from 1 to n using a simple divide operation.\n```\nint trailingZeroes(int n) \n{\n    return n/3125 + n/625 + n/125 + n/25 + n/5;\n}\n```","creationDate":1666380488}}},{"id":"2730248","title":"Trial and Error","url":"/discuss/topic/2730248/trial-and-error","questionTitle":"Wiggle Sort II","post":{"creationDate":1666378972},"post_data":{"id":2730248,"title":"Trial and Error","solutionTags":[{"name":"C++"}],"post":{"id":4387554,"content":"My first attempt was to do alternate from front (first even 0,2,4,.. indices then odd 1,3,5,... indices) ie\n`0,1,2,3,4,5` becomes `0,3,1,4,2,5` and `0,1,2,3,4` becomes `0,3,1,4,2`. \n```\nvoid wiggleSort(vector<int>& nums) \n{\n    int n = nums.size();\n    sort(nums.begin(),nums.end());\n    vector<int> arr(n, 0);\n    for (int i=0; i<n; i+=2)\n        arr[n-1-i] = nums[(n+i)/2]; \n    for (int i=1; i<n; i+=2)\n        arr[n-1-i] = nums[i/2];\n    nums = arr;\n}\n```\nHowever this fails for `4,5,5,6` because it will give us `4,5,5,6`. \nNotice however that alternate from back works ie `5,6,4,5` (again even indices R to L then odd indices R to L). A few more tests should tell you that this is a valid algorithm. Hence gives us an AC. However we have to take special care of whether array size is even or odd. \n\n```\nvoid wiggleSort(vector<int>& nums) \n{\n    int n = nums.size();\n    sort(nums.begin(),nums.end());\n    vector<int> arr(n, 0);\n    for (int i=0; i<n; i+=2)\n        arr[i] = nums[(n-i)/2 - (n%2==0 ? 1 : 0)];\n    for (int i=1; i<n; i+=2)\n        arr[i] = nums[n-1-i/2];\n    nums = arr;\n}\n```","creationDate":1666378972}}},{"id":"2729881","title":"[Faster than 100%] Easy + Concise C++ Step by step","url":"/discuss/topic/2729881/faster-than-100-easy-concise-c-step-by-step","questionTitle":"Fraction to Recurring Decimal","post":{"creationDate":1666371309},"post_data":{"id":2729881,"title":"[Faster than 100%] Easy + Concise C++ Step by step","solutionTags":[],"post":{"id":4387033,"content":"Here is the code without taking care of the recurring decimal (Will give you WA for case `nr=1,dr=3` but still it is useful to understand):\n```\nstring fractionToDecimal(int nr, int dr) \n{\n\tif (nr==0) return \"0\";\n\tstring res = \"\";\n\tif ((nr<0)^(dr<0)) res += \"-\";\n\tnr = abs(nr), dr=abs(dr);\n\tres += to_string(nr/dr);\n\tint rem = nr%dr;\n\tif (rem==0) return res;\n\tres += \".\";\n\twhile (rem>0)\n\t{\n\t\trem *= 10;\n\t\tres += to_string(rem/dr);\n\t\trem %= dr;\n\t}\n\treturn res;\n}\n```\n\nNow we add the recurring decimal part. We will use a hash map to store the position of each decimal digit. If we have seen it earlier than we are due to repeat, hence we break and return.\n\nThere are some gotchas you need to take care of.\n- `abs(INT_MIN)` is `INT_MIN` as defined in `cstdlib.h`.\n- Hence we use `long long int` for our nr and dr.\n- Also use `long long int` for the remainder.\n- You got to be careful about the insertion position of the starting open paranthesis `(`.\n\nFinal code:\n```\nstring fractionToDecimal(long long nr, long long dr) \n{\n    if (nr==0) return \"0\";\n    string res = \"\";\n    if ((nr<0)^(dr<0)) res += \"-\";\n    nr = abs(nr), dr=abs(dr);\n    res += to_string(nr/dr);\n    long long rem = nr%dr;\n    if (rem==0) return res;\n    res += \".\";\n    unordered_map<int,int> decimal;\n    while (rem>0 && decimal.count(rem)==0)\n    {\n        decimal[rem] = res.length();\n        rem *= 10;\n        res += to_string(rem/dr);\n        rem %= dr;\n    }\n    if (rem>0)\n    {\n        res.insert(decimal[rem], \"(\");\n        res += \")\";\n    }\n    return res;\n}\n```\n\n**Result:**\n```\nSuccess\nDetails\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Fraction to Recurring Decimal.\nMemory Usage: 6.3 MB, less than 74.68% of C++ online submissions for Fraction to Recurring Decimal.\n```","creationDate":1666371309}}},{"id":"2729721","title":"Easy Concise DP","url":"/discuss/topic/2729721/easy-concise-dp","questionTitle":"Word Break","post":{"creationDate":1666367634},"post_data":{"id":2729721,"title":"Easy Concise DP","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4386823,"content":"The overall idea is that we maintain a `dp` array of dtype `bool` which denotes whether it is possible for string ending at i. The recursive relation is:\n\n```\ndp[i] = True if any (dp[j] = True and s[j:i] is in wordDict for j in 0..i)\nElse dp[i] = False\n```\nC++ code:\n```\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string>words;\n        for (string w: wordDict) words.insert(w);\n        int n=s.length();\n        \n        vector<bool>valid(n+1,false);\n        valid[0] = true;\n        \n        for (int j=1; j<=n; j++)\n        {\n            bool curr = false;\n            for (int i=0; i<j; i++)\n            {\n                string sub(s.begin()+i, s.begin()+j);\n                if (valid[i] && words.count(sub)){curr=true; break;}\n            }\n            valid[j] = curr;\n        }\n        return valid[n];\n    }\n};\n```","creationDate":1666367634}}},{"id":"2728624","title":"Simple Hashset","url":"/discuss/topic/2728624/simple-hashset","questionTitle":"Insert Delete GetRandom O(1)","post":{"creationDate":1666344180},"post_data":{"id":2728624,"title":"Simple Hashset","solutionTags":[{"name":"C++"}],"post":{"id":4385375,"content":"```\nclass RandomizedSet {\n    unordered_set<int> numset;\npublic:\n    RandomizedSet() {\n    }\n    \n    bool insert(int val) {\n        if (numset.count(val)) return false;\n        numset.insert(val);\n        return true;\n    }\n    \n    bool remove(int val) {\n        if (!numset.count(val)) return false;\n        numset.erase(val);\n        return true;\n    }\n    \n    int getRandom() {\n        int idx = rand() % numset.size();\n        auto it = numset.begin();\n        for (int i=0; i<idx; ++i) ++it;\n        return *it;\n    }\n};\n```","creationDate":1666344180}}},{"id":"2728437","title":"Hashset","url":"/discuss/topic/2728437/hashset","questionTitle":"Contains Duplicate II","post":{"creationDate":1666339672},"post_data":{"id":2728437,"title":"Hashset","solutionTags":[{"name":"C++"}],"post":{"id":4385136,"content":"The idea is to find if we have seen the current value already in the range. Since the search operation in hashset is constant time, hence our algorithm is efficient.\n```\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) \n    {\n        int n=nums.size();\n        unordered_set<int> numset;\n        for (int i=0; i<k && i<n; ++i)\n        {\n            if (numset.count(nums[i])) return true;\n            numset.insert(nums[i]);\n        }\n        for (int i=k; i<n; ++i)\n        {\n            if (numset.count(nums[i])) return true;\n            numset.insert(nums[i]);\n            numset.erase(nums[i-k]);\n        }\n        return false;\n    }\n};\n```\n```\nTC: O(n)\nSC: O(k)\n```","creationDate":1666339672}}},{"id":"2720542","title":"[C++,Python(3/1 lines)] Two methods: Sorting / Max heap","url":"/discuss/topic/2720542/cpython31-lines-two-methods-sorting-max-heap","questionTitle":"Top K Frequent Words","post":{"creationDate":1666154539},"post_data":{"id":2720542,"title":"[C++,Python(3/1 lines)] Two methods: Sorting / Max heap","solutionTags":[{"name":"C++"},{"name":"Python"}],"post":{"id":4374687,"content":"# Sorting:\nWe implement a custom comparator for the condition \"sort by frequency (descending) and for same frequency sort by string (ascending)\"\n```\nbool comp(pair<string,int>a, pair<string,int>b)\n{\n    if (a.second==b.second)\n        return a.first < b.first;\n    return a.second > b.second;\n}\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) \n    {\n        unordered_map<string,int> H;\n        for (string w: words) H[w]++;\n        vector<pair<string,int>> vec;\n        for (auto p: H) vec.push_back({p.first,p.second});\n        sort(vec.begin(),vec.end(),comp);\n        vector<string>res;\n        for (int i=0; i<k; ++i) res.push_back(vec[i].first);\n        return res;\n    }\n};\n```\nSame thing in Python3. Python has inbuilt `collections.Counter` to get frequency map  from array. Also Python\"s sorting API accepts the use of 2 keys if the first key has equal value, hence we need not write a separate comparator function.\n```\nclass Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        counter = Counter(words)\n        sorted_words = sorted(counter.keys(), key=lambda i: (-counter[i], i))\n        return sorted_words[:k]\n```\n\nIf you \"really\" like compact albeit slightly difficult to read code, here is a one-liner for you (though I wont recommend it in real life):\n```\ndef topKFrequent(self, words: List[str], k: int) -> List[str]:\n\treturn [i[0] for i in sorted(Counter(words).items(), key=lambda j: (-j[1],j[0]))][:k]\n```\n\n```\nTC: O( n log(n))\nSC: O(n)\n```\n# Priority Queue\nInstead of sorting we can maintain a priority queue of length K. If length exceeds K, we pop out the last item as per our condition.\n```\nbool comp(pair<string,int>a, pair<string,int>b)\n{\n    if (a.second==b.second)\n        return a.first < b.first;\n    return a.second > b.second;\n}\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) \n    {\n        unordered_map<string,int> H;\n        for (string w: words) H[w]++;\n        priority_queue<pair<string,int>, vector<pair<string,int>>, decltype(comp)*> pq(comp);\n        for (auto p: H)\n        {\n            pq.push({p.first,p.second});\n            if (pq.size()>k) pq.pop();\n        }\n        vector<string>res;\n        while (!pq.empty())\n        {\n            res.insert(res.begin(), pq.top().first);\n            pq.pop();\n        }\n        return res;\n    }\n};\n```\n```\nTC: O(n log(K))\nSC: O(n)\n```\nIf you have any questions dont hesitate to ask. Please upvote if you find this useful.","creationDate":1666154539}}},{"id":"2716972","title":"Top right to bottom left","url":"/discuss/topic/2716972/top-right-to-bottom-left","questionTitle":"Search a 2D Matrix II","post":{"creationDate":1666072878},"post_data":{"id":2716972,"title":"Top right to bottom left","solutionTags":[{"name":"C++"}],"post":{"id":4369992,"content":"The idea is to start from top right cell. If it is larger than target than we can ignore last column, if smaller we can ignore first row. This way we keep moving.\n```\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \n    {\n        int m = matrix.size(), n = matrix[0].size();\n        int i=0, j=n-1;\n        while (i<m && j>=0)\n        {\n            if (matrix[i][j] == target) return true;\n            else if (matrix[i][j] > target) j--;\n            else  i++;\n        }\n        return false;\n    }\n};\n```","creationDate":1666072878}}},{"id":"2716923","title":"Beauty of OOP","url":"/discuss/topic/2716923/beauty-of-oop","questionTitle":"Min Stack","post":{"creationDate":1666072080},"post_data":{"id":2716923,"title":"Beauty of OOP","solutionTags":[{"name":"C++"}],"post":{"id":4369935,"content":"We use pre-built stack class but with our own class object instead of int which will have information on minimum value at any point on stack.\n\n```\nclass Item\n{\n    public:\n    int val;\n    int minVal;\n    Item(int v, int mv): val(v), minVal(mv){}\n};\n\nclass MinStack {\n    stack<Item> stk;\npublic:\n    MinStack() \n    {}\n    \n    void push(int val) \n    {\n        int m = (stk.empty()) ? val : min(stk.top().minVal, val);\n        stk.push(Item(val, m));\n    }\n    \n    void pop() \n    {\n        stk.pop();\n    }\n    \n    int top() \n    {\n        return stk.top().val;\n    }\n    \n    int getMin() \n    {\n        return stk.top().minVal;\n    }\n};\n```","creationDate":1666072080}}},{"id":"2714941","title":"Island method [DFS]","url":"/discuss/topic/2714941/island-method-dfs","questionTitle":"Surrounded Regions","post":{"creationDate":1666023272},"post_data":{"id":2714941,"title":"Island method [DFS]","solutionTags":[{"name":"Depth-First Search"}],"post":{"id":4367286,"content":"This is inspired from my previous posts on simlar questions: [Number of Islands](https://leetcode.com/problems/number-of-islands/discuss/2714931/Easy-DFS) and [Count sub islands](https://leetcode.com/problems/count-sub-islands/discuss/2632544/DFS-solution).\n\nThe idea is to collect all the cells of an island in an array and check if the island is indeed surrounded or not. If it is then we change to X\"s and if not, we revert to original. The check for whether an island is surrounded or not is pretty simple: If any of its cells is a boundary cell then it is not surrounded and if not then it is surrounded.\n\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<char>> &board, int m, int n, int i, int j, vector<pair<int,int>>&isle)\n    {\n        if (i<0||i>=m||j<0||j>=n||board[i][j]!=\"O\") return;\n        board[i][j] = \"*\";\n        isle.push_back({i,j});\n        dfs(board,m,n,i-1,j,isle);\n        dfs(board,m,n,i+1,j,isle);\n        dfs(board,m,n,i,j-1,isle);\n        dfs(board,m,n,i,j+1,isle);\n    }\n    void surround(vector<vector<char>> &board, int m, int n,vector<pair<int,int>>&isle)\n    {\n        bool toSurround = true;\n        for (auto p: isle)\n            if (p.first==0 || p.first==(m-1) || p.second==0 || p.second==n-1)\n            {\n                toSurround = false;\n                break;\n            }\n        if (toSurround)\n        {\n            for (auto p: isle)\n                board[p.first][p.second] = \"X\";            \n        }\n        else\n        {\n            for (auto p: isle)\n                board[p.first][p.second] = \"O\";            \n        }\n        \n    }\n    void solve(vector<vector<char>>& board) \n    {\n        int m = board.size(), n=board[0].size();\n        for (int i=0; i<m; ++i)\n        {\n            for (int j=0; j<n; ++j)\n            {\n                if (board[i][j]==\"O\")\n                {\n                    vector<pair<int,int>> isle;\n                    dfs(board,m,n,i,j,isle);\n                    surround(board,m,n,isle);\n                }\n            }\n        }\n    }\n};\n```\n\nThe other method is to mark all islands having at leat one cell at boundary with `*`. Then if you find land, depending on whether it is marked or not convert it to \"X\" or back to \"O\".\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<char>>& board, int m, int n, int i, int j)\n    {\n        if (i<0||i>=m||j<0||j>=n||board[i][j]!=\"O\") return;\n        board[i][j] = \"*\";\n        dfs(board,m,n,i-1,j);\n        dfs(board,m,n,i+1,j);\n        dfs(board,m,n,i,j-1);\n        dfs(board,m,n,i,j+1);\n    }\n    void solve(vector<vector<char>>& board) \n    {\n        int m = board.size(), n=board[0].size();\n        for (int i=0; i<m; ++i)\n        {\n            dfs(board, m, n, i, 0);\n            dfs(board, m, n, i, n-1);\n        }\n        for (int j=0; j<n; ++j)\n        {\n            dfs(board, m, n, 0, j);\n            dfs(board, m, n, m-1, j);\n        }\n        for (int i=0; i<m; ++i)\n        {\n            for (int j=0; j<n; ++j)\n            {\n                if (board[i][j]==\"*\")\n                    board[i][j] = \"O\";\n                else if (board[i][j] = \"O\")\n                    board[i][j] = \"X\";\n            }\n        }\n        return;\n    }\n};\n```\nCredits for 2nd method goes to [this post](https://leetcode.com/problems/surrounded-regions/discuss/691675/C%2B%2B-Beginner-Friendly-or-Boundary-DFS-or-inPlace)\n\n# Note on TC and SC\nBoth the solutions have `O(m*n)` TC and first solution has `O(m*n)` SC whereas second solution has `O(1)` SC.\n\nIn general for any grid type problem it is impossible to find better than `O(m*n)` TC but the SC can be improved as we saw here.","creationDate":1666023272}}},{"id":"2714931","title":"Easy DFS","url":"/discuss/topic/2714931/easy-dfs","questionTitle":"Number of Islands","post":{"creationDate":1666023051},"post_data":{"id":2714931,"title":"Easy DFS","solutionTags":[{"name":"Depth-First Search"}],"post":{"id":4367269,"content":"The idea is to go over all cells and once you see a 1 (land) start exploring its neighborhood and change grid cell value to 2 to avoid double visits. This way you dont need to maintain a `visited` array.\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<char>>&grid, int i, int j, int m, int n)\n    {\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j]!=\"1\") return;\n        grid[i][j] = \"2\";\n        dfs(grid, i-1, j, m, n);\n        dfs(grid, i+1, j, m, n);\n        dfs(grid, i, j-1, m, n);\n        dfs(grid, i, j+1, m, n);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (grid[i][j]==\"1\")\n                {\n                    dfs(grid, i, j, m, n);\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","creationDate":1666023051}}},{"id":"2706223","title":"Sieve of Eratosthenes with Exaplanation","url":"/discuss/topic/2706223/sieve-of-eratosthenes-with-exaplanation","questionTitle":"Count Primes","post":{"creationDate":1665846873},"post_data":{"id":2706223,"title":"Sieve of Eratosthenes with Exaplanation","solutionTags":[{"name":"C++"}],"post":{"id":4355415,"content":"Sieve of Eratosthenes is the well known algorithm for such count/print primes type problems and the algorithm was invented by him ~2200 years ago!\n\n\nThe algorithm is based on following easily verifiable observation:\n**If a number n is not prime then n will have one or more prime factors in the range `[2,sqrt(n)]`**\n```\nclass Solution {\npublic:\n    int countPrimes(int n)\n    {\n        if (n<2) return 0;\n        vector<bool> prime(n+1,true);\n        for (int p=2; p*p<=n; ++p)\n        {\n            if (!prime[p]) continue;\n            for (int i=p*p; i<=n; i+=p)\n                prime[i] = false;\n        }\n        \n        int ctr = 0;\n        for (int p=2; p<n; ++p) ctr += prime[p];\n        return ctr;\n    }\n};\n```\nIf you are wondering about the inner loop why it starts from `p*p` ie we are marking `[p*p, p*p+p, p*p+2p, p*p+3p,..,n]` and so on and why we are not starting from p ie `[p, 2p, 3p,..,n]`, it is because `[p,2p,..,p*p)` will already be marked by some other smaller prime.","creationDate":1665846873}}},{"id":"2700746","title":"BFS+Queue O(1) space, O(n) time","url":"/discuss/topic/2700746/bfsqueue-o1-space-on-time","questionTitle":"Populating Next Right Pointers in Each Node","post":{"creationDate":1665719921},"post_data":{"id":2700746,"title":"BFS+Queue O(1) space, O(n) time","solutionTags":[{"name":"C++"}],"post":{"id":4348319,"content":"We will use a queue. The children of the level nodes are stored in queue. Then one by one we go over the queue. \n# Puzzle\nNote that we are iterating in the queue in reverse in the line         `for (int i=Q.size()-1; i>=0; --i)`. Can you tell why?\n\n# Code: \n ```\nNode* connect(Node* root) \n{\n    if (!root) return NULL;\n    queue<Node *> Q;\n    Q.push(root);\n    while (!Q.empty())\n    {\n        Node *curr=NULL, *prev=NULL;\n        for (int i=Q.size()-1; i>=0; --i)\n        {\n            curr = Q.front();\n            if (prev) prev->next = curr;\n            Q.pop();\n            if (curr->left) Q.push(curr->left);\n            if (curr->right) Q.push(curr->right);\n            prev = curr;\n        }\n        curr->next = NULL;\n    }\n    return root;\n}\n```\n\nAnswer to puzzle is that because the queue size is increasing on the go, so we can not iterate forwards or else the loop will not end when we want it to end, so we must iterate in reverse.","creationDate":1665719921}}},{"id":"2700676","title":"One pass tortoise and hare","url":"/discuss/topic/2700676/one-pass-tortoise-and-hare","questionTitle":"Delete the Middle Node of a Linked List","post":{"creationDate":1665718732},"post_data":{"id":2700676,"title":"One pass tortoise and hare","solutionTags":[{"name":"C++"}],"post":{"id":4348226,"content":"```\nListNode* deleteMiddle(ListNode* head) \n{\n    if (!head->next) return NULL;\n    if (!head->next->next) return new ListNode(head->val);\n\n    ListNode *fast = head, *slow = head;\n    while (fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    *slow = *(slow->next);\n    return head;\n}\n```","creationDate":1665718732}}},{"id":"2698757","title":"Simple Recursion","url":"/discuss/topic/2698757/simple-recursion","questionTitle":"Flatten Nested List Iterator","post":{"creationDate":1665670248},"post_data":{"id":2698757,"title":"Simple Recursion","solutionTags":[{"name":"C++"},{"name":"Recursion"}],"post":{"id":4345661,"content":"In the constructor itself, I am linearizing the whole thing and storing the data in an array. We recurse inside the nested integer till we get to an integer.\n\n```\nclass NestedIterator {\n    vector<int> arr;\n    int index = 0;\npublic:\n    void linearize(NestedInteger nestInt, vector<int> &res)\n    {\n        if (nestInt.isInteger())\n            res.push_back(nestInt.getInteger());\n        else\n            for (NestedInteger item: nestInt.getList())\n                linearize(item, res);\n        return;\n    }\n    NestedIterator(vector<NestedInteger> &nestedList) \n    {\n        for (NestedInteger nestInt: nestedList)\n            linearize(nestInt, arr);\n    }\n    \n    int next() \n    {\n        return arr[index++];\n    }\n    \n    bool hasNext() \n    {\n        return index < arr.size();\n    }\n};\n\n```","creationDate":1665670248}}},{"id":"2698602","title":"Help needed for DFS solution","url":"/discuss/topic/2698602/help-needed-for-dfs-solution","questionTitle":"Word Search","post":{"creationDate":1665667761},"post_data":{"id":2698602,"title":"Help needed for DFS solution","solutionTags":[],"post":{"id":4345461,"content":"Like others my solution also uses DFS but I am getting TLE. It uses more memory than other approaches (to store copies of intermediate strings `curr` and  boolean`visited` matrices) but can that lead to TLE?\n\n```\nclass Solution {\npublic:\n    bool dfs(vector<vector<char>>& board, int m, int n, int i,  int j, string word, string curr, vector<vector<bool>> visited)\n    {\n        if (i<0 || i>=m || j<0 || j>=n || visited[i][j] || board[i][j]!=word[curr.length()]) return false;\n        visited[i][j] = true;\n        curr.push_back(board[i][j]);\n        if (word==curr) return true;\n        return dfs(board,m,n,i-1,j,word,curr,visited) ||\n               dfs(board,m,n,i+1,j,word,curr,visited) ||\n               dfs(board,m,n,i,j-1,word,curr,visited) ||\n               dfs(board,m,n,i,j+1,word,curr,visited);\n    }\n\n\tbool exist(vector<vector<char>>& board, string word) \n    {\n        int m = board.size(), n = board[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n,false));\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (dfs(board, m, n, i, j, word, \"\", visited))\n                    return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n# EDIT:\nBased on other answers I modified above code to a low memory solution and it gets AC:\n```\nclass Solution {\npublic:\n    bool dfs(vector<vector<char>>& board, int m, int n, int i,  int j, string word, int index)\n    {\n        if (i<0 || i>=m || j<0 || j>=n || board[i][j]!=word[index]) return false;\n        board[i][j] = \"*\";\n        if (index==word.length()-1) return true;\n        bool res =  dfs(board,m,n,i-1,j,word,index+1) ||\n                       dfs(board,m,n,i+1,j,word,index+1) ||\n                       dfs(board,m,n,i,j-1,word,index+1) ||\n                       dfs(board,m,n,i,j+1,word,index+1);\n        board[i][j] = word[index];\n        return res;\n    }\n    bool exist(vector<vector<char>>& board, string word) \n    {\n        int m = board.size(), n = board[0].size();\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (dfs(board, m, n, i, j, word, 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\nNow both of these have same TC (`O(m*n*|word|)`) but SC is lesser (`O(m*n*|word|)`  for the TLE solution vs `O(|word|)` for the AC solution. Can this lead to TLE? Shouldn\"t it be `Memory limited exceeded` or something if it takes too much memory space?","creationDate":1665667761}}},{"id":"2697150","title":"3 solutions","url":"/discuss/topic/2697150/3-solutions","questionTitle":"Delete Node in a Linked List","post":{"creationDate":1665640282},"post_data":{"id":2697150,"title":"3 solutions","solutionTags":[{"name":"C++"}],"post":{"id":4343631,"content":"We can move all values one node to the left.\n```\n    void deleteNode(ListNode* node) \n    {\n        ListNode *curr = node, *prev;\n        while (curr->next)\n        {\n            curr->val = curr->next->val;\n            prev = curr;\n            curr = curr->next;\n        }\n        prev->next = NULL;\n    }\n```\nThis solution has O(N) TC and is accepted.\n\nHowever we can do better! We can just update `node->val` and make `node->next` point to `node->next->next`. That should suffice.\n```\n    void deleteNode(ListNode* node) \n    {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n```\n\nThis solution has O(1) TC and has good score.\nWe can make the code shorter! We can achieve the above with just one line:\n```\n    void deleteNode(ListNode* node) \n    {\n        *node = *(node->next);\n    }\n```\nThis is also O(1), same as 2nd one. The one-liner thing is just a flex, you don\"t need it in a real iterview. 2nd solution is best in my opinion.","creationDate":1665640282}}},{"id":"2696039","title":"[Two methods] Kahn's Algorithm and DFS","url":"/discuss/topic/2696039/two-methods-kahns-algorithm-and-dfs","questionTitle":"Course Schedule II","post":{"creationDate":1665609777},"post_data":{"id":2696039,"title":"[Two methods] Kahn's Algorithm and DFS","solutionTags":[{"name":"C++"}],"post":{"id":4342119,"content":"Construct adjacency list graph and inDegrees array. Then run Kahn\"s algorithm.\n# Kahn\"s algorithm\n- Create two arrays `noIncoming` and `doable` both empty initially\n- Put all courses which have no prerequisites in `noIncoming`\n- While `noIncoming` is not empty \n\t- Pop a node from `noIncoming` and insert in `doable`\n\t- Traverse through adjacency list of this node and for each destination node in this adjacency list:\n\t  - Decrement `inDegree` of this destination node. This is equivalent to breaking an edge\n\t  - if `InDegree` is 0 then insert it into `noIncoming`\n\n```\nclass Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) \n    {\n        unordered_map<int,vector<int>> G;\n        unordered_map<int,int> inDegrees;\n        vector<int> noIncoming, doable;\n        \n        for (auto p: prerequisites)\n        {\n            G[p[1]].push_back(p[0]);\n            inDegrees[p[0]]++;\n        }\n        \n        for (int i=0; i<numCourses; i++)\n            if (inDegrees[i]==0)\n                noIncoming.push_back(i);\n        \n        while (noIncoming.size()>0)\n        {\n            int curr = noIncoming.back();\n            noIncoming.pop_back();\n            doable.push_back(curr);\n            for (int nbd: G[curr])\n            {\n                inDegrees[nbd]--;\n                if (inDegrees[nbd]==0)\n                    noIncoming.push_back(nbd);\n            }\n        }\n        if (doable.size() < numCourses) return {};\n        return doable;\n    }\n};\n```\n\n# DFS\nHere we will need to maintain state of node during DFS. We do it using three colors: White(0) for not visited, Black(1) for visited and completed and Grey(2) for currently visiting and inside recursion.\n```\n// Colors: 0-Not visited, 1-visited and done, 2-visiting and recursion going on\nclass Solution {\n    bool possible = true;\n\npublic:\n    void dfs(unordered_map<int,vector<int>> &G, unordered_map<int,int> &colors, int curr, vector<int> &doable)\n    {\n        if (!this->possible) return;\n        colors[curr] = 2;\n        for (int nbd: G[curr])\n        {\n            if (colors[nbd]==0)\n                dfs(G,colors,nbd,doable);\n            else if (colors[nbd]==2)\n                this->possible = false;\n        }\n        colors[curr] = 1;\n        doable.push_back(curr);\n    }\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) \n    {\n        unordered_map<int,vector<int>> G;\n        unordered_map<int,int> colors;\n        vector<int> doable;\n        \n        for (auto p: prerequisites)\n            G[p[1]].push_back(p[0]);\n        for (int i=0; i<numCourses; i++)\n            colors[i] = 0;\n\n        for (int curr=0; curr<numCourses; curr++)\n        {\n            if (colors[curr]==0)\n                dfs(G, colors, curr, doable);\n        }\n        \n        if (!this->possible) return {};\n        reverse(doable.begin(), doable.end());\n        return doable;\n    }\n};\n```","creationDate":1665609777}}},{"id":"2688732","title":"C++ Hashmap","url":"/discuss/topic/2688732/c-hashmap","questionTitle":"Copy List with Random Pointer","post":{"creationDate":1665462983},"post_data":{"id":2688732,"title":"C++ Hashmap","solutionTags":[{"name":"C++"}],"post":{"id":4332504,"content":"```\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) \n    {\n        if (!head) return head;\n        unordered_map<Node*,Node*> H;\n        Node *curr = head;\n        while(curr)\n        {\n            H[curr] = new Node(curr->val);\n            curr = curr->next;\n        }\n        curr = head;\n        while (curr)\n        {\n            H[curr]->next = H[curr->next];\n            H[curr]->random = H[curr->random];\n            curr = curr->next;\n        }\n        return H[head];\n    }\n};\n```","creationDate":1665462983}}},{"id":"2684917","title":"[6 liner] Simple logic simple solution","url":"/discuss/topic/2684917/6-liner-simple-logic-simple-solution","questionTitle":"Break a Palindrome","post":{"creationDate":1665387320},"post_data":{"id":2684917,"title":"[6 liner] Simple logic simple solution","solutionTags":[{"name":"C++"}],"post":{"id":4327495,"content":"The idea is to walk till centre and stop if you do not see \"a\". If you have reached centre than the input was either a string of type `aaxaa` (odd `len(input)` and centre is not `a`) or `aaa..a` (only a\"s). In both cases, the solution is to replace last character with a \"b\".\n\n```\nclass Solution {\npublic:\n    string breakPalindrome(string palindrome) \n    {\n        int n = palindrome.length(), i=0;\n        if (n==1) return \"\";\n        while (i<n/2 && palindrome[i]==\"a\") i++;\n        if (i==n/2) palindrome[n-1] = \"b\";\n        else palindrome[i] = \"a\";\n        return palindrome;\n    }\n};\n```","creationDate":1665387320}}},{"id":"2670346","title":"BFS using Queue","url":"/discuss/topic/2670346/bfs-using-queue","questionTitle":"Binary Tree Zigzag Level Order Traversal","post":{"creationDate":1665093676},"post_data":{"id":2670346,"title":"BFS using Queue","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"},{"name":"Queue"}],"post":{"id":4307787,"content":"This is a standard BFS problem. BFS traversal always will use a queue and the way it works is you add all the adjoining nodes of current node to queue. Then for these newly added nodes traverse and add their children to the queue but remember to not traverse these children ie mark till where we had added the adjoining and traverse only till there. \n\n```\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if  (!root) return {};\n        queue<TreeNode *> Q;\n        Q.push(root);\n        int level = 1;\n        vector<vector<int>> res;\n        while(!Q.empty())\n        {\n            vector<int> levelVals;\n            for (int i=Q.size()-1; i>=0; --i)\n            {\n                TreeNode *node = Q.front();\n                levelVals.push_back(node->val);\n                if (node->left) Q.push(node->left);\n                if (node->right) Q.push(node->right);\n                Q.pop();\n            }\n            if (level%2 == 0)\n                reverse(levelVals.begin(), levelVals.end());\n            res.push_back(levelVals);\n            level ++;\n        }\n        return res;\n    }\n};\n```\n\n> Then for these newly added nodes traverse and add their children to the queue but remember to not traverse these children ie mark till where we had added the adjoining and traverse only till there.\n\nFor this reason in the inner for loop,\n```\n            for (int i=Q.size()-1; i>=0; --i)\n```\nworks but the following wont work. Although the difference is very subtle.\n```\n            for (int i=0; i<Q.size(); ++i)\n```\nThis is because `Q.size()` is going to change inside for loop so it can be used as initializer but not for termination criterion.","creationDate":1665093676}}},{"id":"2669117","title":"Simple c++ solution with explanation","url":"/discuss/topic/2669117/simple-c-solution-with-explanation","questionTitle":"Plus One","post":{"creationDate":1665070125},"post_data":{"id":2669117,"title":"Simple c++ solution with explanation","solutionTags":[{"name":"C++"}],"post":{"id":4306143,"content":"Logic is to start from right end towards left and till you see nine ,change to zero, Now if stopping point is -1 then this means input was of the form `999..9` so answer has to be `1000..0` and if stopping point is somewhere in the middle then we can just increment it like `...2999` becomes `...3000`.\n\n```\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) \n    {\n        int i = digits.size() - 1;\n        while (i>=0 && digits[i]==9) \n        {\n            digits[i]=0; \n            i--;\n        }\n        if (i==-1) digits.insert(digits.begin(), 1);\n        else digits[i]++;\n        return digits;\n    }\n};\n```\n\n\nWe can also do it in the form of a standard addition. This method will also work if instead of 1, we need to add some other number. This uses the standard \"Carry over\" method of addition.\n```\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int carry = 1;\n        for (int i=digits.size()-1; i>=0; --i)\n        {\n            int temp = (carry+digits[i]);\n            digits[i] = temp%10;\n            carry = temp/10;\n        }\n        if (carry>0) digits.insert(digits.begin(), carry);\n        return digits;\n    }\n};\n```","creationDate":1665070125}}},{"id":"2668565","title":"HashMap + Ordered Map","url":"/discuss/topic/2668565/hashmap-ordered-map","questionTitle":"Time Based Key-Value Store","post":{"creationDate":1665060273},"post_data":{"id":2668565,"title":"HashMap + Ordered Map","solutionTags":[{"name":"C++"},{"name":"Binary Search"}],"post":{"id":4305397,"content":"The underlying idea is to use HashMap for key-wise storing data and ordered map for (timestamp,value) pairs ordered by timestamp for each key. Then we can do `get` and `set` operations for any key using binary search in its corresponding ordered map. More details in comments:\n\n```\nclass TimeMap \n{\n\tprivate:\n    unordered_map<string, map<int,string>> data;\n\n\tpublic:\n    TimeMap() {}\n    \n    void set(string key, string value, int timestamp) \n    {\n        if (!data.count(key))    // New key insertion\n        {\n            data[key] = {{timestamp, value}};\n            return;\n        }\n\t\t// If the same timestamp repeats for any key, replace it. We dont really need this line because of constraint but no harm\n        if (data[key].count(timestamp)) data[key].erase(timestamp);\n\t\t// Finally insert in ordered map\n        data[key].insert({timestamp, value});\n    }\n    \n    string get(string key, int timestamp) \n    {\n        if (!data.count(key)) return \"\";    // key not found\n        auto it = data[key].lower_bound(timestamp);\n        if (it != data[key].end() && (*it).first==timestamp)    // Exact timestamp found\n            return (*it).second;\n        if (it == data[key].begin()) return \"\";    // timestamp asked is before first time set\n        --it;    // it now points to the last time it was set before \"timestamp\"\n        return (*it).second;    // finally return value\n    }\n};\n ```","creationDate":1665060273}}},{"id":"2662762","title":"Easy to understand DFS solution","url":"/discuss/topic/2662762/easy-to-understand-dfs-solution","questionTitle":"Add One Row to Tree","post":{"creationDate":1664949806},"post_data":{"id":2662762,"title":"Easy to understand DFS solution","solutionTags":[],"post":{"id":4297613,"content":"This is a plain DFS problem. Logic in comments.\n```\nclass Solution {\npublic:\n    void dfs(TreeNode *root, int val, int depth, int curDepth)\n    {\n        if (!root) return;\n\t\t// We need to insert as per the rule at this point\n        if (depth==curDepth+1)\n        {\n            root->left = new TreeNode(val, root->left, NULL);\n            root->right = new TreeNode(val, NULL, root->right);\n            return;\n        }\n        dfs(root->left, val, depth, curDepth+1);\n        dfs(root->right, val, depth, curDepth+1);\n    }\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) \n    {\n\t\t// Special case when we have to insert at root\n        if (depth==1) return new TreeNode(val, root, NULL);\n        dfs(root, val, depth, 1);\n        return root;\n    }\n};\n```","creationDate":1664949806}}},{"id":"2661424","title":"Easy hashmap","url":"/discuss/topic/2661424/easy-hashmap","questionTitle":"Group Anagrams","post":{"creationDate":1664913723},"post_data":{"id":2661424,"title":"Easy hashmap","solutionTags":[{"name":"C++"},{"name":"Python"}],"post":{"id":4295824,"content":"Basic idea is to match sorted version of string. Note that anagrams will have same result when sorted. So let us use this as a key for Hashmap.\n\nC++:\n```\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> H;\n        for (string str: strs)\n        {\n            string strsorted = str;\n            sort(strsorted.begin(),strsorted.end());\n            if (H.count(strsorted))\n            {\n                H[strsorted].push_back(str);\n                continue;\n            }\n            H[strsorted] = {str};\n        }\n        vector<vector<string>>res;\n        for (auto p: H) res.push_back(p.second);\n        return res;\n    }\n};\n```\n\nPython:\n```\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        H = {}\n        for str in strs:\n            strsorted = \"\".join(sorted(str))\n            if strsorted in H:\n                H[strsorted].append(str)\n                continue\n            H[strsorted] = [str];\n        return list(H.values())\n```","creationDate":1664913723}}},{"id":"2661294","title":"Spiral traversal","url":"/discuss/topic/2661294/spiral-traversal","questionTitle":"Spiral Matrix","post":{"creationDate":1664911139},"post_data":{"id":2661294,"title":"Spiral traversal","solutionTags":[{"name":"C++"}],"post":{"id":4295658,"content":"Just remember to keep track of start and end indices for x and y directions.\n```\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \n    {\n        int m=matrix.size(), n=matrix[0].size(), i=0, j=0;\n        int sy=0, sx=0, ey=m, ex=n; // m=ey=3, n=ex=4\n        vector<int> res;\n        while (res.size() < m*n)\n        {\n            while (res.size() < m*n && j<ex)\n            {\n                res.push_back(matrix[i][j]);\n                j++;\n            }\n            j--; i++; ex--;\n            while (res.size() < m*n && i<ey)\n            {\n                res.push_back(matrix[i][j]);\n                i++;\n            }\n            i--; j--; ey--;\n            while (res.size() < m*n && j>=sx)\n            {\n                res.push_back(matrix[i][j]);\n                j--;\n            }\n            j++; i--; sx++;\n            while (res.size() < m*n && i>sy)\n            {\n                res.push_back(matrix[i][j]);\n                i--; \n            }\n            i++; j++; sy++;\n        }\n        return res;\n    }\n};\n```","creationDate":1664911139}}},{"id":"2660855","title":"RLE Simulation of \"say\"","url":"/discuss/topic/2660855/rle-simulation-of-say","questionTitle":"Count and Say","post":{"creationDate":1664903840},"post_data":{"id":2660855,"title":"RLE Simulation of \"say\"","solutionTags":[{"name":"C++"}],"post":{"id":4295075,"content":"First write and verify \"say\" function that will write a number in RLE notation. Then the problem becomes easy.\n```\nclass Solution {\npublic:\n    string say(string num)\n    {\n        int i=0;\n        string res = \"\";\n        while(i<num.length())\n        {\n            int j=i;\n            while(j<num.length()&&num[j]==num[i]) j++;\n            res.push_back(j-i+\"0\");\n            res.push_back(num[i]);\n            i = j;\n        }\n        return res;\n    }\n    string countAndSay(int n) \n    {\n        vector<string> vec(n);\n        vec[0] = \"1\";\n        for (int i=1; i<n; i++)\n            vec[i] = say(vec[i-1]);\n        return vec[n-1];\n    }\n};\n```\n\n```\nRuntime: 3 ms, faster than 93.66% of C++ online submissions for Count and Say.\nMemory Usage: 7 MB, less than 33.51% of C++ online submissions for Count and Say.\n```","creationDate":1664903840}}},{"id":"2660501","title":"Faster than 100% -- Rotation pivot using binary search","url":"/discuss/topic/2660501/faster-than-100-rotation-pivot-using-binary-search","questionTitle":"Search in Rotated Sorted Array","post":{"creationDate":1664897705},"post_data":{"id":2660501,"title":"Faster than 100% -- Rotation pivot using binary search","solutionTags":[],"post":{"id":4294619,"content":"Firstly find the pivot of rotation ([reference](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/2741593/Iterative-binary-search)).\nThen find out which side the target would lie wrt pivot and search in that side.\n\n\n```\nclass Solution {\npublic:\n    int countRotations(vector<int>& nums) \n    {\n        int n=nums.size(), lo=0, hi=n-1, mid;\n        while (lo<=hi)\n        {\n            mid = lo + (hi-lo)/2;\n            int prev = (mid-1+n)%n, next = (mid+1)%n;\n            if (nums[mid]<=nums[prev] && nums[mid]<=nums[next])\n                break;\n            else if (nums[mid] <= nums[hi])\n                hi = mid-1;\n            else\n                lo = mid+1; // nums[mid]>=nums[0]\n        }\n        return mid;\n    }\n\n    int search(vector<int>& nums, int target) \n    {\n        int pivot = countRotations(nums);\n        vector<int>::iterator it;\n        if (target < nums[0] || pivot==0)\n            it = lower_bound(nums.begin()+pivot, nums.end(), target);\n        else\n            it = lower_bound(nums.begin(), nums.begin()+pivot, target);\n        if (it==nums.end()) return -1;\n        if (*it==target) return it-nums.begin();\n        return -1;\n    }\n};\n```\n```\nTC: O(log(N))\nSC: O(1)\n```\n```\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array.\nMemory Usage: 11.9 MB, less than 28.90% of C++ online submissions for Search in Rotated Sorted Array.\n```","creationDate":1664897705}}},{"id":"2660003","title":"DP faster than 95%","url":"/discuss/topic/2660003/dp-faster-than-95","questionTitle":"Largest Divisible Subset","post":{"creationDate":1664889498},"post_data":{"id":2660003,"title":"DP faster than 95%","solutionTags":[],"post":{"id":4293953,"content":"The solution is similar to O(N^2) solution for LIS except that we also have to do backtracking, so we maintain 2 values per item in DP: the maximum size of sequence ending at that index and the index of the number it is a multiple of.\n\n```\nbool cmp(pair<int,int>a, pair<int,int>b)\n{\n    return a.first<b.first;\n}\n\nclass Solution {\npublic:\n    vector<int> largestDivisibleSubset(vector<int>& nums) \n    {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<pair<int,int>> dp(n,{1,-1});\n        for (int i=1; i<n; i++)            \n            for (int j=0; j<i; j++)\n                if (nums[i]%nums[j]==0 && 1+dp[j].first>dp[i].first)\n                    dp[i] = {1+dp[j].first,j};\n        auto it = max_element(dp.begin(),dp.end(),cmp);\n        auto p = *it;\n        vector<int> res{nums[it-dp.begin()]};\n        while(p.second>=0)\n        {\n            res.push_back(nums[p.second]);\n            p = dp[p.second];\n        }\n        return res;\n    }\n};\n```\nThis is faster than 95% of solutions:\n```\nRuntime: 52 ms, faster than 95.12% of C++ online submissions for Largest Divisible Subset.\nMemory Usage: 8.9 MB, less than 46.13% of C++ online submissions for Largest Divisible Subset.\n```\n\nI\"m reproducing the O(N^2) solution of LIS for clarity:\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n,1);\n        for (int i=0; i<n; i++)\n            for (int j=0; j<i; j++)\n                if (nums[i]>nums[j])\n                    dp[i] = max(dp[j]+1,dp[i]);\n        return *max_element(dp.begin(),dp.end());\n    }\n};\n```\n\nFor more details on LIS algorithm refer [here](https://leetcode.com/problems/longest-increasing-subsequence/discuss/2660000/Two-DP-solutions).","creationDate":1664889498}}},{"id":"2660000","title":"Two DP solutions","url":"/discuss/topic/2660000/two-dp-solutions","questionTitle":"Longest Increasing Subsequence","post":{"creationDate":1664889459},"post_data":{"id":2660000,"title":"Two DP solutions","solutionTags":[{"name":"C++"}],"post":{"id":4293950,"content":"Fastest O(N log N) solution in C++:\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> sub;\n        for (int n: nums)\n        {\n            if (sub.size()==0 || n > sub[sub.size()-1])\n                sub.push_back(n);\n            else\n            {\n                vector<int>::iterator it = lower_bound(sub.begin(),sub.end(),n);\n                *it = n;\n            }\n        }\n        return sub.size();\n    }\n};\n```\n\nO(N^2) solution:\nC++:\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> dp(n,1);\n        for(int i=0;i<n;i++) for(int j=0;j<i;j++) if(nums[i]>nums[j]) dp[i]=max(dp[i],dp[j]+1); \n        return *max_element(dp.begin(), dp.end());\n    }\n};\n```\nPython:\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1 for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if nums[i]>nums[j]:\n                    dp[i] = max(dp[i], dp[j]+1)\n        return max(dp)\n```\nJava:\n```\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        for(int i=0; i<n; i++)\n        {\n            for (int j=0; j<i; j++)\n            {\n                if(nums[i]>nums[j])\n                {\n                    dp[i] = Math.max(dp[i], dp[j]+1);\n                }\n            }\n        }\n        return Arrays.stream(dp).max().getAsInt();\n    }\n}\n```\nJavaScript:\n```\nvar lengthOfLIS = function(nums) {\n    var n = nums.length;\n    var dp = Array(n);\n    dp.fill(1);\n    for(let i=0; i<n; i++)\n        {\n            for (let j=0; j<i; j++)\n                {\n                    if (nums[i]>nums[j]){\n                        dp[i] = Math.max(dp[i],dp[j]+1);\n                    }\n                }\n        }\n    return Math.max(...dp);\n};\n```","creationDate":1664889459}}},{"id":"2653595","title":"Easy approach O(N) solution based on RLE","url":"/discuss/topic/2653595/easy-approach-on-solution-based-on-rle","questionTitle":"Minimum Time to Make Rope Colorful","post":{"creationDate":1664772466},"post_data":{"id":2653595,"title":"Easy approach O(N) solution based on RLE","solutionTags":[{"name":"C++"}],"post":{"id":4285607,"content":"# Strategy:\nImagine the colors to be written in [RLE](https://en.wikipedia.org/wiki/Run-length_encoding). For eg. \"aabaa\" is written as `{a(2), b(1), a(2)}`. Then when you see a 1, no need to remove anything but when you see anything other than 1, then we have to remove all but the highest time balloon.\n\n```\nclass Solution {\npublic:\n    int minCost(string colors, vector<int>& neededTime) \n    {\n        int i=0, res=0; \n        while (i<colors.length())\n        {\n            int j=i, curSum=0, curMax=INT_MIN;\n            while(j<colors.length() && colors[j]==colors[i])\n            {\n                curSum += neededTime[j];\n                curMax = max(curMax, neededTime[j]);\n                j++;\n            }\n            res += (curSum-curMax);\n            i = j;\n        }\n        return res;\n    }\n};\n```\n\n```\nTC: O(N)\nSC: O(1)\n```","creationDate":1664772466}}},{"id":"2653407","title":"Easy DP with examples","url":"/discuss/topic/2653407/easy-dp-with-examples","questionTitle":"Number of Dice Rolls With Target Sum","post":{"creationDate":1664769940},"post_data":{"id":2653407,"title":"Easy DP with examples","solutionTags":[{"name":"C++"}],"post":{"id":4285368,"content":"Once you ponder over the question, it is easy to find the recurrence relation:\nConsider k (# faces of each die) to be constant. Then, \n```\nrolls(n,target) = rolls(n-1,target-1) + rolls(n-1, target-2) + rolls(n-1, target-3) + ... + rolls(n-1,target-k)\n```\n\nIf you don\"t understand the above equation, consider that first item in the RHS corresponds to the case when last die has value 1 (and so the remaining n-1 dice must sum to target-1), second item corresponds to last die having value 2 (and so the remaining n-1 dice must sum to target-2) and so on such that last item corresponds to last die having value k (and so the remaining n-1 dice must sum to target-k). \n\nWe will create a DP table bottom up. Size of table will be `(n+1, target+1)`. Top row and leftmost column will be zero except `dp[0][0] = 1`.  `dp[i,j]` denotes `rolls(i,j)`\n\nExample of DP table for `numRollsToTarget(1,6,3)`:\n\n| |T=0|T=1|T=2|T=3|\n|--|---|---|---|---|\n| N=0 | 1 | 0 | 0 | 0 |\n| N=1 | 0 | 1 | 1 | 1 |\n\n\nExample of DP table for `numRollsToTarget(2,6,7)`:\n\n| |T=0|T=1|T=2|T=3|T=4|T=5|T=6|T=7\n|--|---|---|---|---|---|---|---|---|\n| N=0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| N=1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |\n| N=2 | 0 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | \n\nThis gives us the following code:\n```\nclass Solution {\npublic:\n    int numRollsToTarget(int n, int k, int target) \n    {\n        vector<vector<int>> dp(n+1, vector<int>(target+1,0));\n        // dp[i,j] denotes numRollsToTarget(i,k,j)\n        dp[0][0] = 1;\n        for (int i=1; i<=n; i++)\n        {\n            for (int j=1; j<=target; j++)\n            {\n                int temp = 0;\n                for (int p=1; p<=min(k,j); p++) \n                    temp += dp[i-1][j-p];\n                dp[i][j] = temp;\n            }\n        }\n        return dp[n][target];\n    }\n};\n```\n\nThe above code is completely correct and will work (for small input). However we need to also handle large input and do the modulo thing. Hence here is the modified version.\n\n```\nclass Solution {\npublic:\n    int numRollsToTarget(int n, int k, int target) \n    {\n        vector<vector<int>> dp(n+1, vector<int>(target+1,0));\n        // dp[i,j] denotes numRollsToTarget(i,k,j)\n        dp[0][0] = 1;\n        int mod = 1000000007;\n        for (int i=1; i<=n; i++)\n        {\n            for (int j=1; j<=target; j++)\n            {\n                int temp = 0;\n                for (int p=1; p<=min(k,j); p++) \n                {\n                    temp = (temp%mod) + ( dp[i-1][j-p]%mod);\n                    temp %= mod;\n                }\n                dp[i][j] = temp;\n            }\n        }\n        return dp[n][target];\n    }\n};\n```","creationDate":1664769940}}},{"id":"2646120","title":"DP Easy Way","url":"/discuss/topic/2646120/dp-easy-way","questionTitle":"Decode Ways","post":{"creationDate":1664632502},"post_data":{"id":2646120,"title":"DP Easy Way","solutionTags":[{"name":"C++"}],"post":{"id":4275144,"content":"Let `n = length(s)`\nNow let `dp` be an array of length `n+1`. Define `dp[i]` as the answer for the string `s[0:i]` that is first `i` characters. Hence `dp[n]` will contain the final answer.\n\nConstructing `dp` array.\n- `dp[0] = 1`\n- `dp[1] = 1` if `s[0] > \"0\"`  else `0`.\n- `dp[i] = (condition1) ? dp[i-2]  : 0   +   (condition2) ? dp[i-1] : 0`\n`condition1` states that the last two characters at` i` form a valid alphabet (b/w [10,26]) and `condtition 2` states that the last character at `i` forms a valid alphabet (b/w [1,9]).\n\n```\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.length();\n        // dp[i] = Answer for s[:i]\n        vector<int> dp(n+1,-1);\n        dp[0] = 1;\n        dp[1] = (s[0]>\"0\")?1:0;\n        for (int i=2; i<=n; i++)\n        {\n            int a = (s[i-2]==\"1\" || (s[i-2]==\"2\" && s[i-1]<=\"6\")) ? dp[i-2] : 0;\n            int b = (s[i-1]>\"0\") ? dp[i-1] : 0;\n            dp[i] = a + b;\n        }\n        return dp[n];\n    }\n};\n```","creationDate":1664632502}}},{"id":"2632544","title":"DFS solution","url":"/discuss/topic/2632544/dfs-solution","questionTitle":"Count Sub Islands","post":{"creationDate":1664321877},"post_data":{"id":2632544,"title":"DFS solution","solutionTags":[{"name":"C++"}],"post":{"id":4257088,"content":"Run DFS for entire table. Create a vector for each island in `grid2`. If all the cells are also 1 in `grid1`, then this island is a sub-island.\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<int>>&grid, int i, int j, int m, int n, vector<pair<int,int>>&isle)\n    {\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j]!=1) return;\n        grid[i][j] = 2;\n        isle.push_back({i,j});\n        dfs(grid,i-1,j,m,n,isle);\n        dfs(grid,i+1,j,m,n,isle);\n        dfs(grid,i,j-1,m,n,isle);\n        dfs(grid,i,j+1,m,n,isle);\n    }\n\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\n        int m = grid1.size(), n = grid1[0].size(), res=0;\n        vector<vector<int>> cells;\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (grid2[i][j]==1)\n                {\n                    vector<pair<int,int>> isle;\n                    dfs(grid2,i,j,m,n,isle);\n                    bool covered = true;\n                    for (auto p: isle)\n                    {\n                        if (grid1[p.first][p.second] != 1)\n                        {\n                            covered = false;\n                            break;\n                        }\n                    }\n                    if (covered) res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","creationDate":1664321877}}},{"id":"2632484","title":"Recursion","url":"/discuss/topic/2632484/recursion","questionTitle":"Swap Nodes in Pairs","post":{"creationDate":1664318260},"post_data":{"id":2632484,"title":"Recursion","solutionTags":[],"post":{"id":4256992,"content":"```\nListNode* swapPairs(ListNode* head) \n{\n\tif (head==NULL || head->next==NULL) return head;\n\tListNode *res = new ListNode(head->next->val);\n\tres->next = new ListNode(head->val);\n\tres->next->next = swapPairs(head->next->next);\n\treturn res;\n}\n```","creationDate":1664318260}}},{"id":"2632475","title":"Two pointers in sorted array","url":"/discuss/topic/2632475/two-pointers-in-sorted-array","questionTitle":"3Sum Closest","post":{"creationDate":1664317728},"post_data":{"id":2632475,"title":"Two pointers in sorted array","solutionTags":[],"post":{"id":4256979,"content":"Any 3 sum problem is best solved by sorting the array and then doing the two pointer method (`O(n^2)`).\n```\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) \n    {\n        int n = nums.size(), closest=nums[0]+nums[1]+nums[2];\n        sort(nums.begin(), nums.end());\n        for (int i=0; i<n-2; i++)\n        {\n            int lo=i+1, hi=n-1;\n            while (lo<hi)\n            {\n                int curr = nums[i]+nums[lo]+nums[hi];\n                if (curr==target) return target;\n                if (abs(target-curr)<abs(target-closest)) closest = curr;\n                if (curr<target) lo ++;\n                else hi--;\n            }\n        }\n        return closest;\n    }\n};\n```","creationDate":1664317728}}},{"id":"2632452","title":"Two pointers + Hashmap","url":"/discuss/topic/2632452/two-pointers-hashmap","questionTitle":"3Sum","post":{"creationDate":1664316761},"post_data":{"id":2632452,"title":"Two pointers + Hashmap","solutionTags":[],"post":{"id":4256950,"content":"The question would be very easy if not for the unique triplet thing. All we need to do is sort the array and for each element `A[i]` solve the `2Sum for sorted array` using the two pointer approach in the subarray `{A[i+1]..A[n-1]}`. \n```\nvector<vector<int>> threeSum(vector<int>& nums, int target=0) {\n\tsort(nums.begin(),nums.end());\n\tint n = nums.size();\n\tvector<vector<int>>res;\n\tfor (int i=0; i<n-2; i++)\n\t{\n\t\tint lo=i+1, hi=n-1;\n\t\twhile (lo<hi)\n\t\t{\n\t\t\tif (nums[i]+nums[lo]+nums[hi]==target) \n\t\t\t{\n\t\t\t\tres.push_back({nums[i],nums[lo],nums[hi]});\n\t\t\t\tlo++;hi--;\n\t\t\t}\n\t\t\telse if (nums[i]+nums[lo]+nums[hi]<target) lo++;\n\t\t\telse hi--;\n\t\t}\n\t}\n\treturn res;\n}\n```\nHowever this will give us duplicate triplets. \n\nTo incorporate the unique triplet thing, we use Hashmaps to store results and before inserting a new result check if it exists already. We use the lowest of the triplet as key and the remaining two are inserted as a pair of ints. There is no particular logic for this choice. You could choose another schema as well.\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums, int target=0) {\n        sort(nums.begin(),nums.end());\n        int n = nums.size();\n        unordered_map<int,vector<pair<int,int>>>H;\n        for (int i=0; i<n-2; i++)\n        {\n            int lo=i+1, hi=n-1;\n            while (lo<hi)\n            {\n                if (nums[i]+nums[lo]+nums[hi]==target) \n                {\n                    bool ok = true;\n                    for (auto p: H[nums[i]])\n                    {\n                        if(nums[lo]==p.first && nums[hi]==p.second)\n                        {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) \n                        H[nums[i]].push_back({nums[lo],nums[hi]}); \n                    lo++;hi--;\n                }\n                else if (nums[i]+nums[lo]+nums[hi]<target) lo++;\n                else hi--;\n            }\n        }\n        vector<vector<int>>res;\n        for (auto kv: H)\n            for (auto p: kv.second)\n                res.push_back({kv.first,p.first,p.second});\n        return res;\n    }\n};\n```","creationDate":1664316761}}},{"id":"2630910","title":"DP LCS variations","url":"/discuss/topic/2630910/dp-lcs-variations","questionTitle":"Shortest Common Supersequence ","post":{"creationDate":1664287683},"post_data":{"id":2630910,"title":"DP LCS variations","solutionTags":[{"name":"C++"}],"post":{"id":4254935,"content":"First solve LCS https://leetcode.com/problems/longest-common-subsequence/\nThen use the DP table and backtrack to construct the answer in reverse.\n- Start at bottom right\n- Case 1: If same as upper left corner of current cell, then `LCS(i,j)=LCS(i-1,j-1)`, hence just copy both the characters. Order will not matter.\n- Case 2.1: If not find out whether the current character is common in both the strings. Hence `LCS(i,j)=LCS(i-1,j-1)+1`. So copy this character but only once.\n- Case 2.2: This is the case when `LCS(i,j)` has come from either `LCS(i-1,j)` (Case 2.2.1) or `LCS(i,j-1)` (Case 2.2.2). Find out which one it is and copy that character and advance the pointer (Only of the two pointers will be advanced).\n- When you reach `i=0` or `j=0`, then just copy the remaining characters.\n\n```\nclass Solution {\npublic:\n    string shortestCommonSupersequence(string str1, string str2) {\n        int n1=str1.length(), n2=str2.length();\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\n        for (int i=1; i<=n1; i++)\n        {\n            for (int j=1; j<=n2; j++)\n            {\n                int a = dp[i-1][j];\n                int b = dp[i][j-1];\n                int c = dp[i-1][j-1];\n                if (str1[i-1]==str2[j-1]) c++;\n                dp[i][j] = max({a,b,c});\n            }\n        }\n        string res;\n        // cout << \"LCS\" << dp[n1][n2] << endl;\n        int i=n1, j=n2;\n        while (i>0 && j > 0)\n        {\n            if (dp[i][j]==dp[i-1][j-1])\n            {\n                // cout << \"case1\" << endl;\n                res += str1[i-1];\n                res += str2[j-1];\n                --i;--j;\n            }\n            else\n            {\n                if (str1[i-1]==str2[j-1])\n                {\n                    // cout << \"case 2.1\" << endl;\n                    res += str1[i-1];\n                    --i; --j;\n                }\n                else\n                {\n                    if (dp[i-1][j]==dp[i][j])\n                    {\n                        // cout << \"case 2.2.1\" << endl;\n                        res += str1[i-1];\n                        --i;\n                    }\n                    else if(dp[i][j-1]==dp[i][j])\n                    {\n                        // cout << \"case 2.2.2\" << endl;\n                        res += str2[j-1];\n                        --j;\n                    }\n                }\n            }\n        }\n        while(i>0)\n        {\n            res += str1[i-1];\n            --i;\n        }\n        while(j>0)\n        {\n            res += str2[j-1];\n            --j;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\nAnother variation of this problem can to find the LCS substring. To solve this, only case 2.2.1 will count.","creationDate":1664287683}}},{"id":"2630532","title":"Three solutions","url":"/discuss/topic/2630532/three-solutions","questionTitle":"Two Sum II - Input Array Is Sorted","post":{"creationDate":1664280310},"post_data":{"id":2630532,"title":"Three solutions","solutionTags":[],"post":{"id":4254452,"content":"HashSet:\n```\nvector<int> twoSum(vector<int>& numbers, int target) \n{\n\tunordered_map<int,int> comps;\n\tfor (int i=0; i<numbers.size(); i++)\n\t{\n\t\tif (comps.count(numbers[i])) return {comps[numbers[i]]+1,i+1};\n\t\tcomps[target-numbers[i]] = i;\n\t}\n\treturn {};\n}\n```\n\nLinear search using two pointers:\n```\nvector<int> twoSum(vector<int>& numbers, int target) \n    {\n        int lo=0, hi=numbers.size()-1;\n        while (lo<hi)\n        {\n            int curr = numbers[lo]+numbers[hi];\n            if (curr==target) return {lo+1,hi+1};\n            else if (curr<target) lo++;\n            else hi--;\n        }\n        return {};\n    }\n```\n\nLinear traversal + Binary search\n```\nvector<int> twoSum(vector<int>& numbers, int target) \n    {\n        for (int i=0; i<numbers.size(); i++)\n        {\n            if (i>0 && numbers[i]==numbers[i-1]) continue;\n            int tmp = target-numbers[i], lo=i+1, hi=numbers.size()-1;\n            while (lo<=hi)\n            {\n                int mid = lo + (hi-lo)/2;\n                if (numbers[mid]==tmp) return {i+1,mid+1};\n                else if (numbers[mid]<tmp) lo=mid+1;\n                else hi=mid-1;\n            }\n        }\n        return {};\n    }\n```","creationDate":1664280310}}},{"id":"2630000","title":"Nearest domino on each side","url":"/discuss/topic/2630000/nearest-domino-on-each-side","questionTitle":"Push Dominoes","post":{"creationDate":1664269931},"post_data":{"id":2630000,"title":"Nearest domino on each side","solutionTags":[{"name":"C++"}],"post":{"id":4253778,"content":"Consider example\n```\n\".L.R...LR..L..\"\n```\nNow any domino which is pushed at t = 0 will remain as it is and we only need to worry about the standing ones (dots).\nNow a domino falls towards right if the nearest non-dot domino in the left side is pushed rightwards. (Situation A). This means the pattern `R....`\nAnd a domino falls towards left if the nearest non-dot domino in the right side is pushed leftwards. (Situation B). This means the pattern `...L`\n\n**How do we do this?**\nCreate a data structure `nearest_left` which denotes for any dot, the nearest non-dot character in its left side along with the distance from itself.\n```\n0: NULL\n2: (L,1)\n4: (R,1)\n5: (R,2)\n6: (R,3)\n9: (R,1)\n10: (R,2)\n12: (L,1)\n13: (L,2)\n```\nSimilarly we have `nearest_right`.\n```\n0: (L,1)\n2: (R,1)\n4: (L,3)\n5: (L,2)\n6: (L,1)\n9: (L,2)\n10: (L,1)\n12: NULL\n13: NULL\n```\n\nNow situation A means `nearest_left` for that dot is a `R` and situation B means `nearest_right` for that dot is a `L`.\n\nNow for any dot we can have:\n- Neither A nor B ==> Remains standing\n- A only ==> falls towards right\n-  B only ==> falls toward left\n- Both A and B. In this case the direction of fall is decided by the nearer of the two. Remain standing if distances same.\n\nFor our example: \n```\n0: B only\n2: Neither A nor B\n4: Both A and B, A wins\n5: Both A and B, Tie.\n6: Both A and B, B wins\n9: Both A and B, A wins\n10: Both A and B, B wins\n12: Neither A nor B\n13: Neither A nor B\n```\n\nThis gives us the answer:\n```\n\"LL.RR.LLRRLL..\"\n```\n\n\n\nNow let us implement this logic\n```\nclass Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int n = dominoes.length();\n        vector<pair<int,pair<char,int>>> nearest_left, nearest_right;\n        int left_idx=-1;\n        char left_ch=\"X\";\n        for (int i=0; i<n; i++)\n        {\n            if (dominoes[i]!=\".\")\n            {\n                left_idx = i;\n                left_ch = dominoes[i];\n            }\n            if (dominoes[i]==\".\")\n                nearest_left.push_back({i,{left_ch,i-left_idx}});\n        }\n        int right_idx=n;\n        char right_ch=\"X\";\n        for (int i=n-1; i>=0; i--)\n        {\n            if (dominoes[i]!=\".\")\n            {\n                right_idx = i;\n                right_ch = dominoes[i];\n            }\n            if (dominoes[i]==\".\")\n                nearest_right.push_back({i,{right_ch,right_idx-i}});\n        }\n        reverse(nearest_right.begin(),nearest_right.end());\n        for (int i=0; i<nearest_left.size(); i++)\n        {\n            auto nl = nearest_left[i], nr = nearest_right[i];\n            int dom_idx = nl.first; // this wil be same as nr.first\n            auto nls = nl.second, nrs = nr.second;\n            if (nls.first==\"R\" && nrs.first==\"L\")\n            {\n                if (nls.second<nrs.second) dominoes[dom_idx] = \"R\";\n                if (nrs.second<nls.second) dominoes[dom_idx] = \"L\";\n                continue;\n            }\n            if (nls.first==\"R\")\n            {\n                dominoes[dom_idx] = \"R\";\n                continue;\n            }    \n            if (nrs.first==\"L\") \n            {\n                dominoes[dom_idx] = \"L\";\n                continue;\n            }\n        }\n        return dominoes;\n    }\n};\n```","creationDate":1664269931}}},{"id":"2409263","title":"Iterative InOrder C++","url":"/discuss/topic/2409263/iterative-inorder-c","questionTitle":"Validate Binary Search Tree","post":{"creationDate":1660187537},"post_data":{"id":2409263,"title":"Iterative InOrder C++","solutionTags":[],"post":{"id":3948907,"content":"```\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        stack<TreeNode *> st;\n        TreeNode *prev; prev = NULL;\n        while (root || !st.empty())\n        {\n            while (root)\n            {\n                st.push(root);\n                root = root->left;\n            }\n            root = st.top();\n            st.pop();\n            if (prev && root->val <= prev->val) return false;\n            prev = root;\n            root = root->right;\n        }\n        return true;\n    }\n};\n```\nThe above is the best solution for this as it requires O(1) space. \n\nA simpler O(N) space solution is to just do recursive  inorder traversal, store all elements in array and check that the array is sorted.  But this is not so impressive though it still does the job.\n```\nclass Solution {\npublic:\n    void inOrderTraversal(TreeNode *root, int *arr, int *n){\n        if (root==NULL) return;\n        inOrderTraversal(root->left, arr, n);\n        *(arr+*n) = root->val;\n        *n = *n+1;\n        inOrderTraversal(root->right, arr, n);\n    }\n    bool isSorted(int arr[], int n){\n        for (int i=1; i<n; i++){if (arr[i]<=arr[i-1]) return 0;} return 1; \n    }\n    bool isValidBST(TreeNode* root) {\n        int *arr = new int[10000000];\n        int n=0;\n        inOrderTraversal(root, arr, &n);\n        return isSorted(arr, n);\n    }\n};\n```","creationDate":1660187537}}},{"id":"2317200","title":"Easy One pass O(1) space solution","url":"/discuss/topic/2317200/easy-one-pass-o1-space-solution","questionTitle":"Partition List","post":{"creationDate":1658486331},"post_data":{"id":2317200,"title":"Easy One pass O(1) space solution","solutionTags":[{"name":"C++"}],"post":{"id":3821976,"content":"Basically create two linked lists: one with nodes less than x and another with nodes greater than or equal to x. After that put 2nd LL at the tail of 1st LL. \n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode *curr=head, *head1=new ListNode, *head2=new ListNode;\n        ListNode *curr1 = head1, *curr2=head2;\n        while (curr)\n        {\n            if (curr->val<x)\n            {\n                curr1->next = new ListNode(curr->val);\n                curr1 = curr1->next;\n            }\n            else\n            {\n                curr2->next = new ListNode(curr->val);\n                curr2 = curr2->next;\n            }\n            curr = curr->next;\n        }\n        curr1->next = head2->next;\n        return head1->next;\n    }\n};\n```\n\n```\nTC: O(N)\nSC: O(1)\n```","creationDate":1658486331}}},{"id":"2161426","title":"Greedy cpp+python","url":"/discuss/topic/2161426/greedy-cpppython","questionTitle":"Non-overlapping Intervals","post":{"creationDate":1655451772},"post_data":{"id":2161426,"title":"Greedy cpp+python","solutionTags":[],"post":{"id":3606398,"content":"```\nbool mycomp(vector<int>&a, vector<int>&b)\n{\n    return a[1]<b[1];\n}\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) \n    {\n        if (intervals.size()==1) return 0;\n        sort(intervals.begin(), intervals.end(), mycomp);\n        int n=intervals.size(), curr=intervals[0][1], res=0;\n        for (int i=1; i<n; i++)\n        {\n            if (intervals[i][0]>=curr) curr = intervals[i][1];\n            else res ++;\n        }\n        return res;\n    }\n};\n```\n\n```\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals, key=lambda k: k[1])\n        n, res, curr = len(intervals), 0, intervals[0][1]\n        for i in range(1,n):\n            if intervals[i][0]>=curr:\n                curr = intervals[i][1]\n\t\t\telse:\n\t\t\t    res += 1\n        return res\n```","creationDate":1655451772}}},{"id":"2153932","title":"Very Easy Hashmap solution + Analysis","url":"/discuss/topic/2153932/very-easy-hashmap-solution-analysis","questionTitle":"Longest String Chain","post":{"creationDate":1655276777},"post_data":{"id":2153932,"title":"Very Easy Hashmap solution + Analysis","solutionTags":[{"name":"C++"}],"post":{"id":3595916,"content":"# Algorithm:\n- Sort words by word length in ascending order\n- Initialize Hashmap H of type `string->int`\n- For each word find subwords (word-1 char) and check if subword is in H. Find the maximum possible value of `H[subword]`  out of all subwords. Call it `ctr`. If there is no subword in H then `ctr=0`\n- `H[word] = ctr+1`\n- Finally answer is the maximum of all values in `H`.\n\n```\nbool complen(string s1, string s2)\n{\n    return s1.length() < s2.length();\n}\n\nclass Solution {\npublic:\n    int longestStrChain(vector<string>& words) {\n        unordered_map<string,int> H;\n        int res=0;\n        sort(words.begin(), words.end(), complen);\n        for (string word: words)\n        {\n            int wn = word.length(), ctr=0;\n            for (int i=0; i<wn; i++)\n            {\n                string sub = string(word.begin(),word.begin()+i) + \n                             string(word.begin()+i+1, word.end());\n                if (H.count(sub)) ctr=max(ctr,H[sub]);\n            }\n            H[word]=ctr+1;\n            res = max(res, H[word]);\n        }\n        return res;\n    }\n};\n```\n```\nTC: O(N*|S| + N*log(N))\nSC: O(N)\n```\nwhere `N=#(words)`, `|S|=max length of word`\n\nReasoning for TC:\n`N*|S|` term comes because for each word we are finding all the subwords\n`N*log(N)` term comes because we are doing a sorting operation in the beginning\n\nReasoning for SC:\nSize of HashMap is N.\n\nPLEASE UPVOTE.","creationDate":1655276777}}},{"id":"2153759","title":"Easy DFS solution","url":"/discuss/topic/2153759/easy-dfs-solution","questionTitle":"All Paths From Source to Target","post":{"creationDate":1655273851},"post_data":{"id":2153759,"title":"Easy DFS solution","solutionTags":[{"name":"C++"}],"post":{"id":3595676,"content":"```\nclass Solution {\npublic:\n    void dfs(vector<vector<int>> graph, int u, int n, vector<int>&path,\n            vector<vector<int>> &paths)\n    {\n        path.push_back(u);\n        if (u==n-1) paths.push_back(path);\n        for (int v: graph[u]) dfs(graph,v,n,path,paths);\n        path.pop_back();\n    }\n    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n        int n=graph.size();\n        vector<int>path;\n        vector<vector<int>> paths;\n        dfs(graph,0,n,path,paths);\n        return paths;\n    }\n};\n```","creationDate":1655273851}}},{"id":"2150834","title":"Edit Distance + LCS DP solutions","url":"/discuss/topic/2150834/edit-distance-lcs-dp-solutions","questionTitle":"Delete Operation for Two Strings","post":{"creationDate":1655202594},"post_data":{"id":2150834,"title":"Edit Distance + LCS DP solutions","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":3591450,"content":"# Solution using Edit Distance Algorithm\n```\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n1=word1.length(), n2=word2.length();\n        vector<vector<int>> dp (n1+1, vector<int>(n2+1,0));\n        for (int i=1; i<=n1; i++) dp[i][0]=i;\n        for (int j=1; j<=n2; j++) dp[0][j]=j;\n        for (int i=1; i<=n1; i++)\n        {\n            for (int j=1; j<=n2; j++)\n            {\n                int a = dp[i-1][j]+1;\n                int b = dp[i][j-1]+1;\n                int c = dp[i-1][j-1];\n                if (word1[i-1]!=word2[j-1]) c+=2;\n                dp[i][j]=min({a,b,c});\n            }\n        }\n        return dp[n1][n2];\n    }\n};\n```\n\nThe only change we made from edit distance algorithm is that we replaced `c++` to `c+=2` inside the `if` condition. This is because now we are not allowed to do substitution but rather we should be deleting on both sides. Everything else is exactly the same.\nReference:https://leetcode.com/problems/edit-distance/\n\n# Solution using LCS algorithm\n## DP using recursion with memoization\n```\nclass Solution {\npublic:\n    int getLCS(string word1, string word2, int n1, int n2, int i, int j, \n               vector<vector<int>>&L)\n    {\n        if (L[i][j]<0)\n        {\n            if (i==n1 || j==n2) L[i][j]=0;\n            else if (word1[i]==word2[j]) \n                L[i][j] = 1 + getLCS(word1,word2,n1,n2,i+1,j+1,L);\n            else L[i][j] = max(getLCS(word1,word2,n1,n2,i+1,j,L), \n                               getLCS(word1,word2,n1,n2,i,j+1,L)\n                              );\n        }\n        return L[i][j];\n    }\n    int minDistance(string word1, string word2) {\n        int n1=word1.length(), n2=word2.length();\n        vector<vector<int>> L(n1+1, vector<int>(n2+1,-1));\n        int lcs = getLCS(word1, word2, n1, n2, 0, 0, L);\n        return n1+n2-2*lcs;\n    }\n};\n```\n## DP using iteration\n```\nclass Solution {\npublic:\n    int getLCS(string word1, string word2, int n1, int n2)\n    {\n        vector<vector<int>> L(n1+1, vector<int>(n2+1,-1));\n        for (int i=n1; i>=0; i--)\n        {\n            for (int j=n2; j>=0; j--)\n            {\n                if (i==n1 || j==n2) L[i][j]=0;\n                else if (word1[i]==word2[j]) L[i][j] = 1+L[i+1][j+1];\n                else L[i][j] = max(L[i+1][j], L[i][j+1]);\n            }\n        }\n        return L[0][0];\n    }\n    int minDistance(string word1, string word2) {\n        int n1=word1.length(), n2=word2.length();\n        int lcs = getLCS(word1, word2, n1, n2);\n        return n1+n2-2*lcs;\n    }\n};\n```","creationDate":1655202594}}},{"id":"2108684","title":"NGE using stack on repeated array","url":"/discuss/topic/2108684/nge-using-stack-on-repeated-array","questionTitle":"Next Greater Element II","post":{"creationDate":1654327063},"post_data":{"id":2108684,"title":"NGE using stack on repeated array","solutionTags":[{"name":"C++"},{"name":"Stack"},{"name":"Monotonic Stack"}],"post":{"id":3532471,"content":"The solution is based on NGE. Except that we repeat the input array twice and return the first n elements as the answer.\n\nFirst let us solve an easier prolem without the circular thing.\nNGE problem for an array\n----------------\n\nConsider you have an array. The problem is that for each element in the array find the first element to the right of that element which is larger than it. If there is none output -1.\nFor example , `A=[2,3,1,4]`. Then output is `{2:3,  3:4,  1:-1,  4:-1}`\nHOW DO YOU SOLVE THIS?\nAnswer is to use a monotonically decreasing stack.  Here is the general strategy\n1. Start with appending `A[0]` to the stack.\n2. As you traverse the array, if you see that `A[i] <= stack top`, push it to the stack making it the new stack top. Thus you will notice that this results in a monotonically decreasing stack.\n2. If ever `A[i]` is greater than the stack top, it means you have found NGE for the number which was at the top of the stack (also the smallest). So pop it and add this pair (`stack top` --> `A[i]`) to your answer. Now check for the new stack top. Continue this till this `A[i]` is the NGE for the stack members.\n3. After you are done, only those which are greater or equal to `A[i]` will remain in the stack. Now push `A[i]` to the stack as well.\n4. At the end, NGE for all elements which remained in the stack is -1.\n```\nvector<int> nextGreaterElements(vector<int> nums) {\n\tint n=nums.size();\n\tstack<pair<int,int>> S;\n\tvector<int> res (n,-1);\n\t\n\tfor (int i=0; i<n; i++)\n\t{\n\t\twhile (!S.empty() && nums[i] > S.top().first)\n\t\t{\n\t\t\tres[S.top().second] = nums[i];\n\t\t\tS.pop();\n\t\t}\n\t\tS.push({nums[i],i});\n\t}\n\treturn res;\n}\n```\n\n---\n\n\nNow for the circular array we just repeat the array twice and run the exact same algorithm.\n\n```\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        for (int i=0; i<n; i++) nums.push_back(nums[i]);\n\n        stack<pair<int,int>> S;\n        vector<int> res (2*n,-1);\n        \n        for (int i=0; i<2*n; i++)\n        {\n            while (!S.empty() && nums[i] > S.top().first)\n            {\n                res[S.top().second] = nums[i];\n                S.pop();\n            }\n            S.push({nums[i],i});\n        }\n        return vector<int>(res.begin(), res.begin()+n);\n    }\n};\n```\n","creationDate":1654327063}}},{"id":"2100813","title":"Stack + HashMap O(N1+N2) solution","url":"/discuss/topic/2100813/stack-hashmap-on1n2-solution","questionTitle":"Next Greater Element I","post":{"creationDate":1654146196},"post_data":{"id":2100813,"title":"Stack + HashMap O(N1+N2) solution","solutionTags":[{"name":"C++"},{"name":"Stack"}],"post":{"id":3521427,"content":"Firstly it is not an easy problem by any stretch. You need to know about both monotonic stacks and hashmaps and use them in a correct way.\nHere is how I did it:\n1. Forget about `nums1`. Solve the NGE (Next Greater Element) problem for `nums2` array and store results in a hashmap\n2. Traverse through `nums1` and append result for each element from the hashmap (they will all be present because it is a subset of `nums2`) into an array and finally return this array.\n\nThe first part is not obvious just like that. So I will explain\n\n---\nNGE problem for an array\n----------------\n\nConsider you have an array. The problem is that for each element in the array find the first element to the right of that element which is larger than it. If there is none output -1.\nFor example , `A=[2,3,1,4]`. Then output is `{2:3,  3:4,  1:-1,  4:-1}`\nHOW DO YOU SOLVE THIS?\nAnswer is to use a monotonically decreasing stack.  Here is the general strategy\n1. Start with appending `A[0]` to the stack.\n2. As you traverse the array, if you see that `A[i] <= stack top`, push it to the stack making it the new stack top. Thus you will notice that this results in a monotonically decreasing stack.\n2. If ever `A[i]` is greater than the stack top, it means you have found NGE for the number which was at the top of the stack (also the smallest). So pop it and add this pair (`stack top` --> `A[i]`) to your answer. Now check for the new stack top. Continue this till this `A[i]` is the NGE for the stack members.\n3. After you are done, only those which are greater or equal to `A[i]` will remain in the stack. Now push `A[i]` to the stack as well.\n4. At the end, NGE for all elements which remained in the stack is -1.\n\n---\n\nIf you get this part, then the other part of question (checking for each item in `nums1`) is very easy. Just check the hashmap you have obtained.\n\nMy code has the exact same logic I have given above.\n```\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int,int> H;\n        stack<int>S;\n        int n1=nums1.size(), n2=nums2.size();\n        for (int i=0; i<n2; i++)\n        {\n            while (!S.empty() && nums2[i]>S.top())\n            {\n                H[S.top()] = nums2[i];\n                S.pop();\n            }\n            S.push(nums2[i]);\n        }\n        while (!S.empty())\n        {\n            H[S.top()]=-1;\n            S.pop();\n        }\n        // We have solved NGE problem for nums2. Now we do 2nd part\n        vector<int>res;\n        for (int num: nums1) res.push_back(H[num]);\n        return res;\n    }\n};\n```\n```\nTC: O(N1+N2)\nSC: O(N2)\n```","creationDate":1654146196}}},{"id":"2041331","title":"Easy DFS solution","url":"/discuss/topic/2041331/easy-dfs-solution","questionTitle":"Deepest Leaves Sum","post":{"creationDate":1652609930},"post_data":{"id":2041331,"title":"Easy DFS solution","solutionTags":[],"post":{"id":3436641,"content":"```\nclass Solution {\npublic:\n    int height(TreeNode *root)\n    {\n        if (!root) return 0;\n        return 1+max(height(root->left),height(root->right));\n    }\n    void util(TreeNode *root, int h, int &res)\n    {\n        if (!root) return;\n        if (h==0) res+=root->val;\n        util(root->left, h-1, res);\n        util(root->right, h-1, res);\n    }\n    int deepestLeavesSum(TreeNode* root) {\n        int H = height(root);\n        int res=0;\n        util(root, H-1, res);\n        return res;\n    }\n};\n```","creationDate":1652609930}}},{"id":"2041034","title":"Dijkstra method","url":"/discuss/topic/2041034/dijkstra-method","questionTitle":"Network Delay Time","post":{"creationDate":1652603793},"post_data":{"id":2041034,"title":"Dijkstra method","solutionTags":[],"post":{"id":3436213,"content":"**Dijsktra\"s Algorithm**: Maintain visited nodes in an array Q. Also maintain the distances from source in an array `dist`. Initially `Q = {source}` and `dist={INT_MAX,INT_MAX,INT_MAX...}`  and `dist[source]=0]`. Then while Q is not empty you do the following\n- Find which node in Q has the minimum value in `dist` array. Call it `u`.\n- For all nodes adjacent to `u`, check if `dist` value can be updated for them. If you update `dist` for any node `v`, then also add `v` to `Q`.\n\nThe standard implementation uses a min-heap.\n```\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int,int>>> graph (n);\n        for (auto item: times)\n        {\n            int u=item[0]-1, v=item[1]-1, w=item[2];\n            graph[u].push_back({v,w});\n        }\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> Q;\n        Q.push({0, k-1});\n        vector<int> dist(n, INT_MAX);\n        dist[k-1] = 0;\n        while (!Q.empty())\n        {\n            auto top = Q.top();\n            Q.pop();\n            int u=top.second, d=top.first;\n            for (auto edge: graph[u])\n            {\n                int v=edge.first, w=edge.second;\n                if (d+w < dist[v])\n                {\n                    dist[v] = d+w;\n                    Q.push({d+w, v});\n                }\n            }\n        }\n        int res = *max_element(dist.begin(), dist.end());\n        return (res==INT_MAX)?-1:res;\n    }\n};\n```\nIf you dont know about heap, the same logic can be implemented without heap as well with some additional cost but still gets an AC.\n```\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int,int>>> graph(n);\n        for (auto edge: times)\n        {\n            int u=edge[0]-1, v=edge[1]-1, w=edge[2];\n            graph[u].push_back({v,w});\n        }\n        vector<int> Q {k-1};\n        vector<int> dist(n, INT_MAX);\n        dist[k-1] = 0;\n        while (Q.size()>0)\n        {\n            int u, minStart=INT_MAX;\n            for (int node: Q)\n            {\n                if (dist[node]<minStart)\n                {\n                    minStart=dist[node];\n                    u = node;\n                }\n            }\n            // u has the min distance out of all nodes in Q\n            Q.erase(find(Q.begin(),Q.end(),u));\n            for (auto edge: graph[u])\n            {\n                int v=edge.first, w=edge.second;\n                if (dist[u]+w < dist[v])\n                {\n                    dist[v] = dist[u]+w;\n                    Q.push_back(v);\n                }\n            }\n        }\n        int res = *max_element(dist.begin(),dist.end());\n        return (res==INT_MAX)?-1:res;\n    }\n};\n```","creationDate":1652603793}}},{"id":"2034170","title":"Connections using Level Wise Traversal DFS","url":"/discuss/topic/2034170/connections-using-level-wise-traversal-dfs","questionTitle":"Populating Next Right Pointers in Each Node II","post":{"creationDate":1652427190},"post_data":{"id":2034170,"title":"Connections using Level Wise Traversal DFS","solutionTags":[{"name":"C++"}],"post":{"id":3426060,"content":"If you do not know [level order traversal problem](https://leetcode.com/problems/binary-tree-level-order-traversal/), refere here:\n[Level Order Traversal - Two DFS solutions](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/2034163/Two-DFS-solutions)\n<br>\nNow we can immediately think of a solution:\nInstead of storing the keys, sotre the node pointers and then make required connections.\n```\nclass Solution {\npublic:\n    void dfs(Node *root, vector<vector<Node *>> &lvn, int level)\n    {\n        if (!root) return;\n        if (level==lvn.size()) lvn.push_back({});\n        lvn[level].push_back(root);\n        dfs(root->left, lvn, level+1);\n        dfs(root->right, lvn, level+1);\n    }\n    Node* connect(Node* root) {\n        vector<vector<Node *>> levelWiseNodes;\n        dfs(root, levelWiseNodes, 0);\n        for (int i=0; i<levelWiseNodes.size(); i++)\n        {\n            if (levelWiseNodes[i].size()<2) continue;\n            for (int j=0; j<=levelWiseNodes[i].size()-2; j++)\n            {\n               levelWiseNodes[i][j]->next = levelWiseNodes[i][j+1];\n            }\n        }\n        return root;\n    }\n};\n```\n","creationDate":1652427190}}},{"id":"2034163","title":"Three methods - Two DFS + One BFS","url":"/discuss/topic/2034163/three-methods-two-dfs-one-bfs","questionTitle":"Binary Tree Level Order Traversal","post":{"creationDate":1652426983},"post_data":{"id":2034163,"title":"Three methods - Two DFS + One BFS","solutionTags":[{"name":"C++"}],"post":{"id":3426050,"content":"Method 1 is to get height of tree, then for each number less than tree height, traverse the tree and get all keys at that level using DFS.\n```\nclass Solution {\npublic:\n    int height(TreeNode *root)\n    {\n        if (!root) return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n    void dfs(TreeNode *root, vector<int>&levelVals, int h)\n    {\n        if (!root || h<0) return;\n        if (h==0) levelVals.push_back(root->val);\n        dfs(root->left, levelVals, h-1);\n        dfs(root->right, levelVals, h-1);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        int H = height(root);\n        vector<vector<int>> res;\n        for (int h=0; h<H; h++)\n        {\n            vector<int> levelVals;\n            dfs(root, levelVals, h);\n            res.push_back(levelVals);\n        }\n        return res;\n    }\n};\n```\nMethod 2 is to do DFS without getting height. Use the logic that if while going down from top, we are at same level as the size of keys array we append a new array and store keys of lower level in new array. \n```\nclass Solution {\npublic:\n    void dfs(TreeNode *root, vector<vector<int>>&res, int level)\n    {\n        if (!root) return;\n        if (res.size()==level) res.push_back({});\n        res[level].push_back(root->val);\n        dfs(root->left, res, level+1);\n        dfs(root->right, res, level+1);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        dfs(root, res, 0);\n        return res;\n    }\n};\n```\n\nBFS Solution:\nHere we will need a queue. The children of the level nodes are stored in queue. Then one by one we go over the queue.\n```\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) \n    {\n        if (!root) return {};\n        vector<vector<int>>res;\n        queue<TreeNode *> Q;\n        Q.push(root);\n        while (!Q.empty())\n        {\n            vector<int> levelVals;\n\t\t\t// We cant go from 0 to Q.size() because Q.size() changes inside for loop\n\t\t\t// Hence we initialize i once using Q.size() and iterate in reverse.\n            for (int i=Q.size()-1; i>=0; i--)\n            {\n                TreeNode *node = Q.front();\n                Q.pop();\n                levelVals.push_back(node->val);\n                if (node->left) Q.push(node->left);\n                if (node->right) Q.push(node->right);\n            }\n            res.push_back(levelVals);\n        }\n        return res;\n    }\n};\n```","creationDate":1652426983}}},{"id":"2030957","title":"DP solution","url":"/discuss/topic/2030957/dp-solution","questionTitle":"Count Sorted Vowel Strings","post":{"creationDate":1652334132},"post_data":{"id":2030957,"title":"DP solution","solutionTags":[{"name":"C++"}],"post":{"id":3421489,"content":"```\nclass Solution {\npublic:\n    int countVowelStrings(int n) {\n        int a=1, b=1, c=1, d=1, e=1;\n        for (int i=2; i<=n; i++)\n        {\n            d+=e;\n            c+=d;\n            b+=c;\n            a+=b;\n        }\n        return a+b+c+d+e;\n    }\n};\n```","creationDate":1652334132}}},{"id":"2025591","title":"Floyd's Tortoise and Hare Algorithm","url":"/discuss/topic/2025591/floyds-tortoise-and-hare-algorithm","questionTitle":"Linked List Cycle II","post":{"creationDate":1652183016},"post_data":{"id":2025591,"title":"Floyd's Tortoise and Hare Algorithm","solutionTags":[],"post":{"id":3413908,"content":"Consider a situation like this.\n![](https://i.imgur.com/jGtHiGq.png)\n\nConsider two pointers `tortoise` and `hare` which move at 1x and 2x respectively.\nWe know that `d(hare)=2d(tortoise)`. So, when they meet we have:\n```\nF+nC+a = 2(F+a)\n```\nLHS is for hare and RHS is for tortoise.\nThen we make the tortoise start again from the beginning and hare from the meeting position itself but both at 1x. Then they meet exactly at the cycle start point because after F steps, tortoise is at `F` and hare is at `F+a+F`. But we know that `F+a=nC` from earlier equation. Hence hare is also at `F` and this node is the answer.\n\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *tortoise=head, *hare=head;\n        while(1)\n        {\n            if (!hare||!hare->next) return NULL;\n            tortoise = tortoise->next;\n            hare = hare->next->next;\n            if (tortoise==hare) break;\n        }\n        tortoise = head;\n        while (tortoise!=hare)\n        {\n            tortoise = tortoise->next;\n            hare = hare->next;\n        }\n        return hare;\n    }\n};\n```\n\nThere is obviously also an easier O(N) space HashSet solution that gives you an AC but I think the Floyd\"s algo solution is more useful in real life interview. For the sake of completion here is the HashSet solution:\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set<ListNode *> S;\n        while (head)\n        {\n            if (S.count(head)) return head;\n            S.insert(head);\n            head = head->next;\n        }\n        return NULL;        \n    }\n};\n```\n\n","creationDate":1652183016}}},{"id":"2024027","title":"DFS and All combinations","url":"/discuss/topic/2024027/dfs-and-all-combinations","questionTitle":"Combination Sum III","post":{"creationDate":1652144091},"post_data":{"id":2024027,"title":"DFS and All combinations","solutionTags":[],"post":{"id":3411719,"content":"We can do DFS and check for current sum. If meets the condition add to result.\nC++ solution:\n```\nclass Solution {\npublic:\n    void combn(int curr, int target, int count,  vector<vector<int>> &res, vector<int> &v)\n    {\n        if (count<0 || target<0) return;\n        if (count==0 && target==0)\n        {\n            res.push_back(v);\n            return;\n        }\n        for (int i=curr; i<=9; i++)\n        {\n            v.push_back(i);\n            combn(i+1, target-i, count-1, res, v);\n            v.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int>> res;\n        vector<int>v;\n        combn(1,n,k,res,v);\n        return res;\n    }\n};\n```\nWe can also do all combinations and get an AC:\nPython solution:\n```\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        res = []\n        for cb in combinations(range(1,10),k):\n            if sum(cb)==n:\n                res.append(list(cb))\n        return res\n```","creationDate":1652144091}}},{"id":"2023987","title":"O(N^3), O(N^2), O(N log N) and O(N) solutions","url":"/discuss/topic/2023987/on3-on2-on-log-n-and-on-solutions","questionTitle":"132 Pattern","post":{"creationDate":1652142151},"post_data":{"id":2023987,"title":"O(N^3), O(N^2), O(N log N) and O(N) solutions","solutionTags":[{"name":"C++"}],"post":{"id":3411668,"content":"# O(N^3)  solution\nBrute force to test all triplets for the required condition. This requires a triple for loop.\nPseudocode:\n```\nfor i in 0..n\n\tfor j in in i+1..n\n\t\tfor k in  j+1..n\n\t\t  if nums[i]<nums[k]<nums[j]\n\t\t    return true\nreturn false\n```\nThis is trivial to implement and guaranteed to be TLE so no need to code this.\n\n# O(N^2) solution\nWe can eliminate one for loop!\nWe can do this by keeping track of min element to the left as `minLeft`. If `minLeft==nums[i]`, we need not test for the condition and if not, we try to find an appropriate item in the right side.\n```\nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n=nums.size();\n        if (n<3) return false;\n        int minLeft=nums[0];\n        for (int j=0; j<n; j++)\n        {\n            minLeft = min(minLeft, nums[j]);\n            if (minLeft==nums[j]) continue;\n            for (int k=n-1; k>j; k--)\n                if (nums[k]>minLeft && nums[k]<nums[j])\n                    return true;\n        }\n        return false;\n    }\n};\n```\nUnfortunately this gives TLE on the last test case. So, we need to improve.\n\n# O(N log N) solution\nWe can replace the 2nd for loop that we use to find the right element by a binary search heuristic.\nWe traverse the array right to left and maintain a sorted array by inserting at the appropriate location obtained using binary search. We also maintain a very important array `largestSmaller` such that `largestSmaller[i] =`  `largest of the items to the right of nums[i] which are all smaller than nums[i]`. Essentially this is the `2` in the `132` that we need. Now if we get anything less than this element in the left side, we have a triplet.\n```\nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n=nums.size(), minLeft=INT_MAX, minRight=INT_MAX;\n        if (n<3) return false;\n        vector<int> largestSmaller(n,0), sortedRight;\n        for (int i=n-1;i>=0;i--)\n        {\n            minRight = min(minRight, nums[i]);\n            if (nums[i]==minRight){\n                sortedRight.insert(sortedRight.begin(),nums[i]);\n                largestSmaller[i]=nums[i];\n            }\n            else\n            {\n                vector<int>::iterator low=lower_bound(sortedRight.begin(), sortedRight.end(), nums[i]);\n                int pos=low-sortedRight.begin();\n                largestSmaller[i] = sortedRight[pos-1];\n                sortedRight.insert(sortedRight.begin()+pos, nums[i]);\n            }\n        }\n        for (int i=0; i<n; i++)\n        {\n            minLeft = min(minLeft, nums[i]);\n            if (minLeft<nums[i] && minLeft<largestSmaller[i] && nums[i]>largestSmaller[i]) return true;\n        }\n        return false;\n    }\n};\n```\n\nSadly this O(N log N) solution also gives a TLE.\nHowever, [I knew of a bug in LC where it accepts python but says TLE for cpp](https://leetcode.com/discuss/general-discussion/1743011/c-tle-vs-python-ac-issue) and decided to try coding the exact same logic in python\n```\nclass Solution:\n    def find132pattern(self, nums: List[int]) -> bool:\n        n, minLeft, minRight = len(nums), 10**9+1, 10**9+1\n        if n<3: return False\n        largestSmaller, sortedRight = [0 for _ in range(n)],[]\n        for i in range(n-1,-1,-1):\n            minRight = min(minRight, nums[i])\n            if nums[i]==minRight:\n                sortedRight.insert(0, nums[i])\n                largestSmaller[i] = nums[i]\n            else:\n                pos = bisect_left(sortedRight, nums[i])\n                largestSmaller[i] = sortedRight[pos-1]\n                sortedRight.insert(pos, nums[i])\n        for i in range(n):\n            minLeft = min(minLeft, nums[i])\n            if minLeft<largestSmaller[i]<nums[i]:\n                return True\n        return False\n```\nWith this, we get an AC !!\nHowever this may not work in a real life coding test, so we need to get an O(N) solution\n\n# O(N) solution\nThe idea is similar as above. The only trick is that instead of using a sorted array to find the right element, we can use a stack. We traverse right to left and store all elements smaller than the current element in a monotonically decreasing stack. Then later if ever we find that the current element is less than the element at the top of the stack, we have found a triplet.\n\n```\nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n=nums.size();\n        if (n<3) return false;\n        stack<int> rightNums;\n        int largestSmaller = INT_MIN;\n        for (int i=n-1; i>=0; i--)\n        {\n            if (nums[i]<largestSmaller) return true;\n            else\n            {\n                while (rightNums.size()>0 && nums[i]>rightNums.top())\n                {\n                    largestSmaller = rightNums.top();\n                    rightNums.pop();\n                }\n            }\n            rightNums.push(nums[i]);\n        }\n        return false;\n    }\n};\n```\nExample:\n`[1,8,5,6,7,9,10]`\nThen right to left we get a stream 10,9,7,6,5,8,1\nSo, we get `stack=10,9,7,6,5`\nThen when we see 8: `stack=10,9,8` (5,6,7 are popped in that order) and `largestSmaller=7`. This means from now on we can look for a potential triplet if we see anything less than 7 (like 1) and the triplet is (1,8,7)\n\n\nThis solution gives us an AC and also places us at the top 5%.","creationDate":1652142151}}},{"id":"2021432","title":"Iterative solution","url":"/discuss/topic/2021432/iterative-solution","questionTitle":"Letter Combinations of a Phone Number","post":{"creationDate":1652073393},"post_data":{"id":2021432,"title":"Iterative solution","solutionTags":[{"name":"C++"},{"name":"Python"}],"post":{"id":3408090,"content":"# Method:\nCreate a string array. In the beginning it has only one member which is empty string. Then when you see a digit, create a new array which is each member of old array plus each letter of new digit. Then replace the old array with the new one. Then go to next digit and so on.\nExample:\nInput: \"23\"\nArray in the process:\n```\nstart=> [\"\"]\ndigit=\"2\"=> [\"a\", \"b\", \"c\"]\ndigit=\"3\"=> [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n```\n\nc++:\n```\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if (digits.size()==0) return {};\n        unordered_map<char,vector<char>> mapping;\n        mapping[\"2\"]={\"a\",\"b\",\"c\"};\n        mapping[\"3\"]={\"d\",\"e\",\"f\"};\n        mapping[\"4\"]={\"g\",\"h\",\"i\"};\n        mapping[\"5\"]={\"j\",\"k\",\"l\"};\n        mapping[\"6\"]={\"m\",\"n\",\"o\"};\n        mapping[\"7\"]={\"p\",\"q\",\"r\",\"s\"};\n        mapping[\"8\"]={\"t\",\"u\",\"v\"};\n        mapping[\"9\"]={\"w\",\"x\",\"y\",\"z\"};\n        vector<string>words {\"\"};\n        for (char digit: digits)\n        {\n            vector<string> new_words;\n            for (string word: words)\n                for (char letter: mapping[digit])\n                    new_words.push_back(word+letter);\n            words=new_words;\n        }\n        return words;\n    }\n};\n```\n\npython:\n```\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if len(digits) == 0: return []\n        mapping = {\"2\": \"abc\", \"3\": \"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\n        words = [\"\"]\n        for digit in digits:\n            letters = mapping[digit]\n            new_words = []\n            for word in words:\n                for letter in letters:\n                    new_words.append(word+letter)\n            words = new_words\n        return words\n```","creationDate":1652073393}}},{"id":"2012656","title":"Solution using stack","url":"/discuss/topic/2012656/solution-using-stack","questionTitle":"Remove All Adjacent Duplicates in String II","post":{"creationDate":1651815104},"post_data":{"id":2012656,"title":"Solution using stack","solutionTags":[{"name":"C++"},{"name":"Stack"}],"post":{"id":3395168,"content":"Maintain a stack of (char, frequency) pair.\nHere is how it works for a test case.\n#### Input:\n```\ns = \"deeedbbcccbdaa\", k = 3\n```\n#### Dry run:\nFirst column is where you are at. Second column is the stack at that time\n```\nd : [[\"d\", 1]] \ne : [[\"d\", 1], [\"e\", 1]] \ne : [[\"d\", 1], [\"e\", 2]] \ne : [[\"d\", 1]] #You popped here\nd : [[\"d\", 2]] \nb : [[\"d\", 2], [\"b\", 1]] \nb : [[\"d\", 2], [\"b\", 2]] \nc : [[\"d\", 2], [\"b\", 2], [\"c\", 1]] \nc : [[\"d\", 2], [\"b\", 2], [\"c\", 2]] \nc : [[\"d\", 2], [\"b\", 2]] #You popped here\nb : [[\"d\", 2]] #You popped here\nd : [] #You popped here\na : [[\"a\", 1]] \na : [[\"a\", 2]] \n```\n#### Answer:\nJust join the elements in stack:\n```\n\"aa\"\n```\n\nNow we are ready to code!\n# Code:\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s, int k) {\n        stack<pair<char,int>> H;\n        for (char ch: s)\n        {\n            if (H.empty() || H.top().first!=ch) H.push({ch,1});\n            else\n            {\n                H.top().second++;\n                if (H.top().second==k) H.pop();\n            }\n        }\n        string t=\"\";\n        while (!H.empty())\n        {\n            auto p=H.top(); \n            t+=string(p.second,p.first);\n            H.pop();\n        }\n        reverse(t.begin(),t.end());\n        return t;\n    }\n};\n```","creationDate":1651815104}}},{"id":"2008732","title":"Two Sum Approach","url":"/discuss/topic/2008732/two-sum-approach","questionTitle":"Max Number of K-Sum Pairs","post":{"creationDate":1651695022},"post_data":{"id":2008732,"title":"Two Sum Approach","solutionTags":[{"name":"C++"}],"post":{"id":3389554,"content":"We use a HashMap based standard two sum approach.\n```\nclass Solution {\npublic:\n    int maxOperations(vector<int>& nums, int target) {\n        unordered_map<int,int> comps;\n        int ctr=0;\n        for (int n: nums)\n        {\n            if (comps.count(n) && comps[n]>0)\n            {\n                ctr++;\n                comps[n]--;\n            } else comps[target-n]++;\n        }\n        return ctr;\n    }\n};\n```\n\n```\nTC: O(n)\nSC: O(n)\n```","creationDate":1651695022}}},{"id":"1986727","title":"DFS solution","url":"/discuss/topic/1986727/dfs-solution","questionTitle":"Smallest String With Swaps","post":{"creationDate":1651071296},"post_data":{"id":1986727,"title":"DFS solution","solutionTags":[{"name":"C++"},{"name":"Depth-First Search"}],"post":{"id":3357673,"content":"- Create graph using `pairs` as adjancency list.\n- Start with a node. Do DFS traversal. Sort the node ids (string indices) and characters both. Then put the characters in order.\n- Repeat for all nodes. Do not do for already visited nodes.\n\n```\nclass Solution {\npublic:\n    int n;\n    vector<vector<int>> edges;\n    vector<bool> visited;\n    \n    void DFS(int src, vector<int>&visited_nodes)\n    {\n        visited[src]=true;\n        visited_nodes.push_back(src);\n        for (int dest: edges[src])\n            if (!visited[dest]) DFS(dest, visited_nodes);\n    }\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) \n    {\n        n = s.size();\n        edges =  vector<vector<int>>(n, vector<int>{});\n        for (auto p: pairs)\n        {\n            int u=p[0], v=p[1];\n            edges[u].push_back(v);\n            edges[v].push_back(u);\n        }\n        visited = vector<bool>(n, false);\n        for (int u=0; u<n; u++)\n        {\n            if (!visited[u])\n            {\n                vector<int> visited_nodes;\n                DFS(u, visited_nodes);\n                vector<char> visited_chars;\n                for (int i: visited_nodes) visited_chars.push_back(s[i]);\n                sort(visited_chars.begin(), visited_chars.end());\n                sort(visited_nodes.begin(), visited_nodes.end());\n                for (int i=0; i<visited_nodes.size(); i++)\n                    s[visited_nodes[i]]=visited_chars[i];\n            }\n        }\n        return s;\n    }\n};\n```","creationDate":1651071296}}},{"id":"1975633","title":"3 Sum over keys","url":"/discuss/topic/1975633/3-sum-over-keys","questionTitle":"3Sum With Multiplicity","post":{"creationDate":1650727946},"post_data":{"id":1975633,"title":"3 Sum over keys","solutionTags":[{"name":"C++"}],"post":{"id":3341455,"content":"```\nclass Solution {\npublic:\n    int threeSumMulti(vector<int>& arr, int target) {\n        int n = arr.size(), MAX=101, res=0, MOD=1000000007;\n        vector<int> frequencies(MAX, 0);\n        for (int k: arr) frequencies[k]++;\n        for (int x=0; x<MAX; x++)\n        {\n            for (int y=x+1; y<MAX; y++)\n            {\n                int z=target-x-y;\n                if (z>y && z<MAX)\n                {\n                    long long a=frequencies[x], b=frequencies[y], c=frequencies[z];\n                    long long d = a*b*c;\n                    res += d%MOD;\n                    res %= MOD;\n                }\n            }\n        }\n        for (int x=0; x<MAX; x++)\n        {\n            int y = target-2*x; //x,x,y\n            if (y>x && y<MAX)\n            {\n                long long a=frequencies[x], b=frequencies[y];\n                long long c = b * a * (a-1)/2;\n                res += c%MOD;\n                res %= MOD;\n            }\n        }\n        for (int x=0; x<MAX; x++)\n        {\n            int y = (target-x)/2; // x,y,y\n            if (y>x && (target-x)%2==0 && y<MAX)\n            {\n                long long a=frequencies[x], b=frequencies[y];\n                long long c = a * b * (b-1)/2;\n                res += c%MOD;\n                res %= MOD;\n            }\n        }\n        if (target%3==0)\n        {\n            int x=target/3;\n            long long a=frequencies[x];\n            long long b = a * (a-1) * (a-2)/6;\n            res += b%MOD;\n            res %= MOD;\n        }\n        return res;\n    }\n};\n```\n\n```\nTC: O(MAX^2)\nSC: O(MAX)\n```\nwhere `MAX` is the maximum value in the array (here 100).\nNotice that the complexities do not depend on the length of `arr`.","creationDate":1650727946}}},{"id":"1974704","title":"Easy HashMap solution","url":"/discuss/topic/1974704/easy-hashmap-solution","questionTitle":"Encode and Decode TinyURL","post":{"creationDate":1650704215},"post_data":{"id":1974704,"title":"Easy HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":3340200,"content":"```\nclass Solution {\npublic:\n    unordered_map<int,string> int2url;\n    unordered_map<string,int> url2int;\n    string base_url = \"http://tiny.io/\";\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl) {\n        if (url2int.find(longUrl)==url2int.end())\n        {\n            int ctr=url2int.size();\n            url2int[longUrl] = ctr;\n            int2url[ctr] = longUrl;\n        }\n        return base_url+to_string(url2int[longUrl]);\n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl) {\n        string nstr = string(shortUrl.begin()+15,shortUrl.end());\n        int n = stoi(nstr);\n        return int2url[n];\n    }\n};\n```","creationDate":1650704215}}},{"id":"1968608","title":"Hashing using modulo","url":"/discuss/topic/1968608/hashing-using-modulo","questionTitle":"Design HashMap","post":{"creationDate":1650517815},"post_data":{"id":1968608,"title":"Hashing using modulo","solutionTags":[{"name":"C++"}],"post":{"id":3331398,"content":"We learn this in college. It is good to get a chance to implement.\nHere we use modulo operator as the hashing function and M is chosen to be a big enough prime.\n```\nclass Node {\n    public:\n    int key;\n    int val;\n    Node *next;\n    Node(int k, int v, Node *n){key=k;val=v;next=n;}\n};\n\nclass MyHashMap {\npublic:\n    vector<Node *>nodes;\n    int N;\n    MyHashMap(int n=99991) {\n        nodes = vector<Node *>(n,NULL);\n        N = n;        \n    }\n    \n    void put(int key, int value) {\n        int h = key%N;\n        if (nodes[h]==NULL)\n        {\n            nodes[h]=new Node(key,value,NULL);\n            return;\n        }\n        Node *curr=nodes[h];\n        while (curr!=NULL)\n        {\n            if (curr->key==key)\n            {\n                curr->val=value;\n                return;\n            }\n            curr=curr->next;\n        }\n        while (curr->next!=NULL) curr=curr->next;\n        curr->next=new Node(key,value,NULL);\n    }\n    \n    int get(int key) {\n        int h = key%N;\n        if (nodes[h]==NULL) return -1;\n        Node *curr = nodes[h];\n        while (curr!=NULL)\n        {\n            if (curr->key==key) return curr->val;\n            curr=curr->next;\n        }\n        return -2;\n    }\n    \n    void remove(int key) {\n        int h=key%N;\n        if (nodes[h]==NULL) return;\n        if (nodes[h]->key==key) \n        {\n            nodes[h]=nodes[h]->next;\n            return;\n        }\n        Node *curr=nodes[h];\n        while (curr->next!=NULL && curr->next->key!=key) curr=curr->next;\n        curr->next = curr->next->next;        \n    }\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */\n```\n\nI solved the HashSet problem too using similar method: <https://leetcode.com/problems/design-hashset/discuss/1968599/Hashing-using-modulo>","creationDate":1650517815}}},{"id":"1968599","title":"Hashing using modulo","url":"/discuss/topic/1968599/hashing-using-modulo","questionTitle":"Design HashSet","post":{"creationDate":1650517735},"post_data":{"id":1968599,"title":"Hashing using modulo","solutionTags":[{"name":"C++"}],"post":{"id":3331387,"content":"Here we use modulo operator as the hashing function and M is chosen to be a big enough prime.\n```\nclass Node {\n    public:\n    int val;\n    Node *next;\n    Node(int v, Node *n){val=v;next=n;}\n};\nclass MyHashSet {\npublic:\n    vector<Node *>nodes;\n    int N;\n    MyHashSet(int n=99991) {\n        nodes = vector<Node *>(n,NULL);\n        N = n;\n    }\n    \n    void add(int key) {\n        if (contains(key)) return;\n        int h = key%N;\n        if (nodes[h]==NULL) nodes[h]=new Node(key,NULL);\n        else\n        {\n            Node *curr=nodes[h];\n            while (curr->next!=NULL) curr=curr->next;\n            curr->next=new Node(key,NULL);\n        }\n    }\n    \n    void remove(int key) {\n        if (!contains(key)) return;\n        int h=key%N;\n        if (nodes[h]->val==key) \n        {\n            nodes[h]=nodes[h]->next;\n            return;\n        }\n        Node *curr=nodes[h];\n        while (curr->next!=NULL && curr->next->val!=key) curr=curr->next;\n        curr->next = curr->next->next;\n    }\n    \n    bool contains(int key) {\n        int h=key%N;\n        if (nodes[h]==NULL) return false;\n        Node *curr=nodes[h];\n        while (curr!=NULL) \n        {\n            if (curr->val==key) return true;\n            curr=curr->next;\n        }\n        return false;\n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj->add(key);\n * obj->remove(key);\n * bool param_3 = obj->contains(key);\n */\n```","creationDate":1650517735}}},{"id":"1966446","title":"O(1) space solution","url":"/discuss/topic/1966446/o1-space-solution","questionTitle":"Game of Life","post":{"creationDate":1650453097},"post_data":{"id":1966446,"title":"O(1) space solution","solutionTags":[],"post":{"id":3328214,"content":"**TC of both solutions is O(M\\*N)**\n# O(1) Space solution\nUse 2 bits to maintain board. Left bit to store new values and right bit for original values.\n```\nclass Solution {\npublic:\n    int getNumNeighbors(vector<vector<int>>board,int m,int n, int i, int j)\n    {\n        int ctr=0;\n        for (int x=max(i-1,0);x<min(i+2,m);x++)\n            for (int y=max(j-1,0);y<min(j+2,n);y++) ctr+=board[x][y]&1;\n        ctr-=board[i][j]&1;\n        return ctr;\n    }\n    void gameOfLife(vector<vector<int>>& board) {\n        int m=board.size(), n=board[0].size();\n        for (int i=0;i<m;i++)\n        {\n            for (int j=0;j<n;j++)\n            {\n                int num_neighbors=getNumNeighbors(board,m,n,i,j);\n                if (board[i][j]==1 && num_neighbors<2) board[i][j]=1;\n                if (board[i][j]==1 && num_neighbors>3) board[i][j]=1;\n                if (board[i][j]==0 && num_neighbors==3)board[i][j]=2;\n                if (board[i][j]==1 && (num_neighbors==2 || num_neighbors==3))board[i][j]=3;\n            }\n        }\n        for (int i=0;i<m;i++) for (int j=0;j<n;j++) board[i][j]>>=1;\n    }\n};\n```\n\n# O(M\\*N) space solution\nUse auxiliary board variable to store new board values. Finally replace original with auxiliary.\n```\nclass Solution {\npublic:\n    int getNumNeighbors(vector<vector<int>>board,int m,int n, int i, int j)\n    {\n        int ctr=0;\n        for (int x=max(i-1,0);x<min(i+2,m);x++)\n            for (int y=max(j-1,0);y<min(j+2,n);y++) ctr+=board[x][y];\n        ctr-=board[i][j];\n        return ctr;\n    }\n\n    void gameOfLife(vector<vector<int>>& board) {\n        int m=board.size(), n=board[0].size();\n        vector<vector<int>> board_c(m,vector<int>(n,0));\n        for (int i=0;i<m;i++)\n        {\n            for (int j=0;j<n;j++)\n            {\n                int num_neighbors=getNumNeighbors(board,m,n,i,j);\n                if (board[i][j]==1 && num_neighbors<2) board_c[i][j]=0;\n                if (board[i][j]==1 && num_neighbors>3) board_c[i][j]=0;\n                if (board[i][j]==0 && num_neighbors==3)board_c[i][j]=1;\n                if (board[i][j]==1 && (num_neighbors==2 || num_neighbors==3))board_c[i][j]=1;\n            }\n        }\n        board = board_c;\n    }\n};\n```","creationDate":1650453097}}},{"id":"1966261","title":"Two solutions: Easy and Medium","url":"/discuss/topic/1966261/two-solutions-easy-and-medium","questionTitle":"Binary Search Tree Iterator","post":{"creationDate":1650447965},"post_data":{"id":1966261,"title":"Two solutions: Easy and Medium","solutionTags":[{"name":"C++"}],"post":{"id":3327930,"content":"# Easy Solution\nJust traverse the array and store keys in an array. Then return answer from array.\n```\nclass BSTIterator {\npublic:\n    vector<int>keys;\n    int idx;\n    void traverse(TreeNode *root, vector<int>&keys_v)\n    {\n        if (root==NULL) return;\n        traverse(root->left, keys_v);\n        keys_v.push_back(root->val);\n        traverse(root->right, keys_v);\n    }\n    BSTIterator(TreeNode* root) {\n        traverse(root, keys);\n        idx=0;\n    }\n    \n    int next() {\n        return keys[idx++];\n    }\n    \n    bool hasNext() {\n        return idx < keys.size();\n    }\n};\n```\n```\nTC: O(1)\nSC: O(n)\n```\n# Medium Solution\nUse stack to go as left as possible accumulating the nodes. Then return from bottom left and move to right (Accumulate nodes from right node to left-wards).\n```\nclass BSTIterator {\npublic:\n    stack<TreeNode *>nodes;\n    void pushLeft(TreeNode *root)\n    {\n        while (root!=NULL)\n        {\n            nodes.push(root);\n            root=root->left;\n        }\n    }\n    BSTIterator(TreeNode* root) {\n        pushLeft(root);\n    }\n    \n    int next() {\n        if (nodes.size()>0)\n        {\n            TreeNode *leftBottom = nodes.top();\n            nodes.pop();\n            pushLeft(leftBottom->right);\n            return leftBottom->val;\n        }\n        else return -1;\n        \n    }\n    \n    bool hasNext() {\n        return nodes.size()>0;\n    }\n};\n\n```\n```\nTC: \\u03B8(1) \nSC: O(h)\n```","creationDate":1650447965}}},{"id":"1963699","title":"Two approaches","url":"/discuss/topic/1963699/two-approaches","questionTitle":"Spiral Matrix II","post":{"creationDate":1650371889},"post_data":{"id":1963699,"title":"Two approaches","solutionTags":[{"name":"C++"}],"post":{"id":3324167,"content":"# Approach1\nThis approach is based on using min, max for x and y carefully. Basically. You go in cycles of \n```\nIncrement Y\nIncreement X\nDecrement Y\nDecrement X\n```\nThe bounds also have to change so that we traverse the spiral.\n```\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> M(n, vector<int>(n,0));\n        int x=0, y=0, curr=1, x_min=0, x_max=n-1, y_min=0, y_max=n-1;\n        while (x>x_min||x<x_max||y>y_min||y<y_max)\n        {\n            while (y<y_max) M[x][y++]=curr++; x_min++;\n            while (x<x_max) M[x++][y]=curr++; y_max--;\n            while (y>y_min) M[x][y--]=curr++; x_max--;\n            while (x>x_min) M[x--][y]=curr++; y_min++;     \n        }\n        M[x][y]=curr;\n        return M;\n    }\n};\n```\n\n```\nTC: O(n^2)\nSC: O(1)\n```\n\nVerdict:\nFaster than 100% solutions\nMemory less than 90% solutions\n# Approach 2\nThis approach uses an observation:\nFor N=3 ie 9 elements, we see the pattern `v=[3,2,2,1,1]` (Total 9) ie 3 numbers from Left to Right => then 2 from Top to Bottom ==> then 2 from Right to Left ==> then 1 from Bottom to Top ==> then 1 from Left to Right.\nSimilarly for N=4 ie 16 elements, the pattern is `v=[4,3,3,2,2,1,1]`.\nSimilarly for N=5 ie 25 elements we have `v=[5,4,4,3,3,2,2,1,1]`\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> M(n, vector<int>(n,0));\n        vector<int>v;\n        for (int i=1;i<n;i++){v.push_back(i);v.push_back(i);} v.push_back(n-1);\n        reverse(v.begin(),v.end());\n        // 2,2,2,1,1\n        int curr=1;\n        int x=0,y=0;\n        for (int i=0; i<v.size(); i++)\n        {\n            for (int j=0; j<v[i]; j++)\n            {\n                M[x][y]=curr;\n                curr++;\n                if (i%4==0) y++;\n                if (i%4==1) x++;\n                if (i%4==2) y--;\n                if (i%4==3) x--;\n            }\n        }\n        M[x][y]=curr;\n        return M;\n    }\n};\n```\n\n```\nTC: O(n^2)\nSC: O(n)\n```\n\nVerdict:\nFaster than 100% solutions\nMemory less than 30% solutions\n\n","creationDate":1650371889}}},{"id":"1953374","title":"Easy method","url":"/discuss/topic/1953374/easy-method","questionTitle":"Trapping Rain Water","post":{"creationDate":1650118517},"post_data":{"id":1953374,"title":"Easy method","solutionTags":[{"name":"C++"}],"post":{"id":3309721,"content":"Water trapped at any point is equal to `min(max_to_the_left, max_to_the_right) - h` where `h` is its own height.\nSo all we need to do is find out that for each point, what is the maximum height to its left and maximum height to its right. This can be achieved in a fairly easy way: Just traverse through the array Left to Right and keep track of the max element seen. Similarly do the same but from Right to Left.\nFinally, we do one last traversal to find the total water accumulated but this time from `1 to n-2` because the elements `0` and `n-1` (first and last) cannot hold water.\n\n```\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        int curr=0;\n        vector<int> maxLtoR(n,0), maxRtoL(n,0);\n        for (int i=0; i<n; i++)\n        {\n            curr = max(curr, height[i]);\n            maxLtoR[i] = curr;\n        }\n        curr = 0;\n        for (int i=n-1; i>=0; i--)\n        {\n            curr = max(curr, height[i]);\n            maxRtoL[i] = curr;\n        }\n        int amt_here, total_amt=0;\n        for (int i=1; i<n-1; i++)\n        {\n            amt_here =  min(maxLtoR[i], maxRtoL[i]) - height[i];\n            total_amt += amt_here;\n        }\n        return total_amt;\n    }\n};\n```\n\n```\nTC: O(n)\nSC: O(n)\n```","creationDate":1650118517}}},{"id":"1952298","title":"Easy HashMap solution","url":"/discuss/topic/1952298/easy-hashmap-solution","questionTitle":"Convert BST to Greater Tree","post":{"creationDate":1650092614},"post_data":{"id":1952298,"title":"Easy HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":3308287,"content":"Given that all keys in the tree are unique we can use a HashMap of the structure `unordered_map<int,TreeNode*>` to store the tree. Then we can do the operations asked and substitute appropriate values as the new keys.\n```\nclass Solution {\npublic:\n    void traverse(TreeNode *root, unordered_map<int, TreeNode *>&H)\n    {\n        if (root==NULL) return;\n        H[root->val] = root;\n        traverse(root->left, H);\n        traverse(root->right, H);\n    }\n    TreeNode* bstToGst(TreeNode* root) {\n        unordered_map<int, TreeNode *> H;\n        traverse(root, H);\n        vector<int> v1, v2;\n        for (auto item: H) v1.push_back(item.first);\n        sort(v1.begin(),v1.end(), greater<int>());\n        int curr=0;\n        for (int i: v1)\n        {\n            v2.push_back(curr+i);\n            curr+=i;\n        }\n        for (int i=0; i<v1.size(); i++) H[v1[i]]->val = v2[i];\n        return root;\n    }\n};\n```","creationDate":1650092614}}},{"id":"1952288","title":"Easy HashMap solution","url":"/discuss/topic/1952288/easy-hashmap-solution","questionTitle":"Binary Search Tree to Greater Sum Tree","post":{"creationDate":1650092283},"post_data":{"id":1952288,"title":"Easy HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":3308274,"content":"Given that all keys in the tree are unique we can use a HashMap of the structure `unordered_map<int,TreeNode*>` to store the tree. Then we can do the operations asked and substitute appropriate values as the new keys.\n```\nclass Solution {\npublic:\n    void traverse(TreeNode *root, unordered_map<int, TreeNode *>&H)\n    {\n        if (root==NULL) return;\n        H[root->val] = root;\n        traverse(root->left, H);\n        traverse(root->right, H);\n    }\n    TreeNode* bstToGst(TreeNode* root) {\n        unordered_map<int, TreeNode *> H;\n        traverse(root, H);\n        vector<int> v1, v2;\n        for (auto item: H) v1.push_back(item.first);\n        sort(v1.begin(),v1.end(), greater<int>());\n        int curr=0;\n        for (int i: v1)\n        {\n            v2.push_back(curr+i);\n            curr+=i;\n        }\n        for (int i=0; i<v1.size(); i++) H[v1[i]]->val = v2[i];\n        return root;\n    }\n};\n```","creationDate":1650092283}}},{"id":"1950731","title":"Recursive C++ solution","url":"/discuss/topic/1950731/recursive-c-solution","questionTitle":"Trim a Binary Search Tree","post":{"creationDate":1650047409},"post_data":{"id":1950731,"title":"Recursive C++ solution","solutionTags":[{"name":"C++"}],"post":{"id":3306181,"content":"The important observation is that:\n**If  parent<low => parent->left < low**\nSimilarly\n**If  parent>high => parent->right> high**\nThus we can reject the entire subtree depending on this condition.\n\nWe can build the tree recursively and return `root`.\n\n```\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root==NULL) return root;\n        if (root->val < low) return trimBST(root->right, low, high);\n        if (root->val > high) return trimBST(root->left, low, high);\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n        return root;\n    }\n};\n```","creationDate":1650047409}}},{"id":"1894572","title":"Classical solution two heaps","url":"/discuss/topic/1894572/classical-solution-two-heaps","questionTitle":"Find Median from Data Stream","post":{"creationDate":1648562933},"post_data":{"id":1894572,"title":"Classical solution two heaps","solutionTags":[{"name":"C++"},{"name":"Heap (Priority Queue)"}],"post":{"id":3226257,"content":"This is a classical heaps question.\nThe solution is to maintain two heaps, a max heap of lower than median values and a min heap of higher than median values. On querying for median, you return from the top of whichever heap as an extra element or in case both have same number of elements (size of array is even), then avarage of top of both heaps.\n\n```\nclass MedianFinder {\npublic:\n    priority_queue<int> q1; //lower half is a max heap\n    priority_queue<int, vector<int>, greater<int>> q2; // upper half is a min heap\n    MedianFinder() {        \n    }\n    \n    void addNum(int num) {\n        if (q1.size()==0 || num < q1.top()) q1.push(num);\n        else q2.push(num);\n        if (q1.size() > q2.size()+1)\n        {\n            q2.push(q1.top());\n            q1.pop();\n        } else if (q2.size() > q1.size()+1)\n        {\n            q1.push(q2.top());\n            q2.pop();\n        }\n    }\n    \n    double findMedian() {\n        int n1=q1.size(), n2=q2.size();\n        if (n1 > n2) return q1.top();\n        else if (n2 > n1) return q2.top();\n        else if (n1==n2) return .5 * (double)q1.top() + .5 * (double)q2.top();\n        return -1;\n    }\n};\n```","creationDate":1648562933}}},{"id":"1889353","title":"3 line simplest O(n log n ) solution by sorting","url":"/discuss/topic/1889353/3-line-simplest-on-log-n-solution-by-sorting","questionTitle":"Top K Frequent Words","post":{"creationDate":1648400347},"post_data":{"id":1889353,"title":"3 line simplest O(n log n ) solution by sorting","solutionTags":[{"name":"Python"}],"post":{"id":3218710,"content":"We need the answer in decreasing order of frequency but increasing order lexicographically. To take both into account we make the frequencies negative and use both in increasing order with desired priority for sorting.\n\n```\nclass Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        counter = Counter(words)\n        sorted_words = sorted(counter.keys(),  key=lambda i: (-counter[i], i))\n        return sorted_words[:k]\n```\nI used python because it has a inbuilt counter. If you are using another language you can use hashmap to create a counter yourself.","creationDate":1648400347}}},{"id":"1889288","title":"Simply simulate the steps","url":"/discuss/topic/1889288/simply-simulate-the-steps","questionTitle":"Number of Steps to Reduce a Number in Binary Representation to One","post":{"creationDate":1648399039},"post_data":{"id":1889288,"title":"Simply simulate the steps","solutionTags":[{"name":"C++"}],"post":{"id":3218628,"content":"**How do you add 1 to a binary string**\nA: Go from right to left, if you see a one, make it zero. If you see a zero, make it one and stop. If you could not find zero then create a string like `1000` for `111`.\n\n**How do you divide a binary string by 2**\nA: Just right shift by  1.\n\nNow that we have both of these pieces, we can simulate the steps:\n\n\n```\nstring add_one(string s, int l)\n{\n    int i=l-1;\n    while (i>=0 && s[i]!=\"0\")\n    {\n        s[i]=\"0\";\n        i--;\n    }\n    if (i>=0) s[i]=\"1\";\n    else s=\"1\"+s;\n    return s;\n}\n\nstring divide_by_two(string s)\n{\n    return string(s.begin(), s.end()-1);\n}\n\nclass Solution {\npublic:\n    int numSteps(string s) {\n        int ctr=0;\n        while (s!=\"1\")\n        {\n            int l = s.length();\n            if (s[l-1]==\"0\") s = divide_by_two(s);\n            else s = add_one(s, l);\n            ctr ++;\n        }\n        return ctr;\n    }\n};\n```","creationDate":1648399039}}},{"id":"1820603","title":"House Robber","url":"/discuss/topic/1820603/house-robber","questionTitle":"Delete and Earn","post":{"creationDate":1646457622},"post_data":{"id":1820603,"title":"House Robber","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":3118401,"content":"Notice that whichever number you choose to earn, you can earn all instances of that number and none of the number to the left or right.\nHence, we need to find the frequency or rather the total points possible for earning each number and then run a House Robber on that.\n\nHouse robber can be solved using DP. Here I have given two ways to solve it: using a DP array or using just two integer variables.\n\n```\nclass Solution {\npublic:\n    int rob_v1(vector<int> money)\n    {\n        int n=money.size();\n        if (n==1) return money[0];\n        vector<int> dp(n,0);\n        dp[0] = money[0]; dp[1] = max(money[0], money[1]);\n        for (int i=2; i<n; i++) dp[i] = max(dp[i-2]+money[i], dp[i-1]);\n        return dp[n-1];\n    }\n    \n    int rob_v2(vector<int>  money)\n    {\n        int n=money.size();\n        if (n==1) return money[0];\n        int a=money[0], b=max(money[0], money[1]), b_old;\n        for (int i=2; i<n; i++)\n        {\n            b_old = b;\n            b = max(a+money[i], b);\n            a = b_old;\n        }\n        return b;\n    }\n    int deleteAndEarn(vector<int>& nums) {\n        int maxNum = 10000;\n        vector<int> points(maxNum, 0);\n        for (int n: nums) points[n-1]+=n;\n        return rob_v2(points);\n    }\n};\n```","creationDate":1646457622}}},{"id":"1816829","title":"Faster than 100% C++ solutions and also very easy to understand","url":"/discuss/topic/1816829/faster-than-100-c-solutions-and-also-very-easy-to-understand","questionTitle":"Arithmetic Slices","post":{"creationDate":1646327700},"post_data":{"id":1816829,"title":"Faster than 100% C++ solutions and also very easy to understand","solutionTags":[{"name":"C++"}],"post":{"id":3112710,"content":"Given you have a arithmetic sequence (AS) of length 4 as in the example, you can quickly see that:\n- Number of AS of length 3 = (4-3+1)=2\n- Number of AS of length 4 = (4-4+1)=1\n\nHence, Number of AS = 2+1 = 3\n\nYou can extend this logic to this:\n**Given an AS of maximum length L, `total number of AS=1+2+3+..+L-2 = 1/2*(L-2)*(L-1)`**\n\nSo, what we need to do is as we traverse through the array, find out the AS (we keep moving the 2nd pointer till the AS is finished) and then calculate the total number of AS using above formula. \n\nNow for the fun part:\n\n```\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& nums) {\n        int n=nums.size(), i=0, res=0;\n        while (i<n-2)\n        {\n            int start=i;\n            while (i<n-2 && nums[i+1]-nums[i]==nums[i+2]-nums[i+1]) i++;\n            int L = i+2-start;\n            int num_subs = (L-2)*(L-1)/2;\n            res += num_subs;\n            i++;\n        }\n        return res;\n    }\n};\n```","creationDate":1646327700}}},{"id":"1768336","title":"HashSet 2 solutions O(n) and O(nk)","url":"/discuss/topic/1768336/hashset-2-solutions-on-and-onk","questionTitle":"Check If a String Contains All Binary Codes of Size K","post":{"creationDate":1644763363},"post_data":{"id":1768336,"title":"HashSet 2 solutions O(n) and O(nk)","solutionTags":[{"name":"C++"}],"post":{"id":3037180,"content":"# Sol1: HashSet of int: O(n)\n\n```\nclass Solution {\npublic:\n    bool hasAllCodes(string s, int k) {\n        unordered_set<int> S;\n        int curr = 0, n=s.size(), useful=(1<<(k-1))-1;\n        if (n<k) return false;\n        for (int i=0; i<k; i++) curr = curr*2 + (s[i]-\"0\");\n        S.insert(curr);\n        for (int i=k; i<n; i++)\n        {\n            curr = curr&useful;\n            curr = curr << 1;\n            curr = curr + (s[i]-\"0\");\n            S.insert(curr);\n        }\n        return S.size()==(1<<k);\n    }\n};\n```\n\n# Sol2: HashSet of string: O(nk)\n```\nclass Solution {\npublic:\n    bool hasAllCodes(string s, int k) {\n        unordered_set<string> S;\n        int n=s.size();\n        for (int i=0; i<n-k+1; i++) S.insert(string(s.begin()+i,s.begin()+i+k));\n        return S.size()==(1<<k);\n    }\n};\n```\n","creationDate":1644763363}}},{"id":"1767153","title":"Simple Iterative solution","url":"/discuss/topic/1767153/simple-iterative-solution","questionTitle":"Subsets","post":{"creationDate":1644728709},"post_data":{"id":1767153,"title":"Simple Iterative solution","solutionTags":[{"name":"C++"}],"post":{"id":3035273,"content":"- Start with `curr = [[]]`\n- Iterate over `nums`. At each iteration, double the size of subsets.\n- To do this just take all current elements of `curr`. Append last seen element `nums[i]` to these arrays and push them back to `curr`.\n```\n#define pb push_back\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> curr;\n        curr.pb({});\n        for (int n: nums)\n        {\n            int sz=curr.size();\n            for (int i=0; i<sz; i++){auto v = curr[i]; v.pb(n); curr.pb(v);}\n        }\n        return curr;\n    }\n};\n```","creationDate":1644728709}}},{"id":"1762374","title":"Sliding window","url":"/discuss/topic/1762374/sliding-window","questionTitle":"Permutation in String","post":{"creationDate":1644559117},"post_data":{"id":1762374,"title":"Sliding window","solutionTags":[{"name":"C++"}],"post":{"id":3027622,"content":"# Algorithm\n- Create an array of size 26 storing letter frequencis of  `s1`.\n- Similarly do it for `s2` but just upto `n1` where `n1=s1.size()`\n- Slide winow in `s2` and add the upcoming letter and subtract the outgoing letter\n- If the frequency table matches return True\n- Finally return false if it never matched\n\n\n```\nclass Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        int n1=s1.size(), n2=s2.size();\n        if (n1>n2) return false;\n        vector<int> v1(26,0), v2(26,0);\n        for (char ch: s1) v1[ch-\"a\"]++;\n        for (int i=0; i<n2; i++)\n        {\n            v2[s2[i]-\"a\"]++;\n            if (i>=n1) v2[s2[i-n1]-\"a\"]--;\n            if (v1==v2) return true;\n        }\n        return false;\n    }\n};\n```","creationDate":1644559117}}},{"id":"1762334","title":"O(N) HashMap cummulative sum","url":"/discuss/topic/1762334/on-hashmap-cummulative-sum","questionTitle":"Subarray Sum Equals K","post":{"creationDate":1644558330},"post_data":{"id":1762334,"title":"O(N) HashMap cummulative sum","solutionTags":[{"name":"C++"}],"post":{"id":3027573,"content":"# Algorithm:\n- Maintain a HashMap of cummulative sum of array using variable `curr`\n- If you see that `curr-k` is in HashMap, add it to the count of contiguous subarrays\n- Add `curr` to the HashMap.\n\n```\n#define ll long long\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int n=nums.size(), res=0; ll curr=0;\n        unordered_map<ll,int> H;\n        H[0] = 1; // At i=-1 we have seen 0\n        for (int i=0; i<n; i++)\n        {\n            curr+=nums[i];\n            if (H.count(curr-k)) res+=H[curr-k];\n            H[curr]++;\n        }\n        return res;\n    }\n};\n```","creationDate":1644558330}}},{"id":"1759029","title":"O(N^2) log(N) Binary Search [AC]","url":"/discuss/topic/1759029/on2-logn-binary-search-ac","questionTitle":"Valid Triangle Number","post":{"creationDate":1644437020},"post_data":{"id":1759029,"title":"O(N^2) log(N) Binary Search [AC]","solutionTags":[{"name":"C++"},{"name":"Binary Tree"}],"post":{"id":3022456,"content":"Firstly sort `nums`.\nNow chose 1st two sides of triangle in for loop. \nSay `a=nums[i], b=nums[j]` where `i<j`. \nFor the 3rd side of the triangle, check the lowest index where `a+b` or any number greater than that occurs in case `a+b` is absent. Call this index as `k`.\nThen, valid triangles can be with chosen `a`, `b` and  `c` can be chosen from index between indices `j` and `k`.\n\n\n```\nclass Solution {\npublic:\n    int triangleNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), res=0;\n        for (int i=0; i<n; i++)\n        {\n            for (int j=i+1; j<n; j++)\n            {\n                auto it = lower_bound(nums.begin(), nums.end(), nums[i]+nums[j]);\n                int pos = it-nums.begin();\n                if (pos-j-1>0) res+=(pos-j-1);\n            }\n        }\n        return res;\n    }\n};\n```","creationDate":1644437020}}},{"id":"1750340","title":"DP Solution very straightforward | Seam Carving","url":"/discuss/topic/1750340/dp-solution-very-straightforward-seam-carving","questionTitle":"Minimum Falling Path Sum","post":{"creationDate":1644162652},"post_data":{"id":1750340,"title":"DP Solution very straightforward | Seam Carving","solutionTags":[{"name":"Python"},{"name":"Dynamic Programming"}],"post":{"id":3008760,"content":"- Create a `dp` matrix of size (nxn)\n- Copy last row of `matrix` to last row of `dp`\n- Iteratively go up from `r=n-2` to `r=0`. For element `(r,c)` the expression we have is: `dp[r,c] = min(dp[r+1,c-1], dp[r+1,c], dp[r+1,c+1])`\n- For `c=0` and `c=n-1` take min of only two elements rather than 3. These are left and right edges\n- After reaching top row, check which element in top row is the minimum.\n- Done!\n\n\n```\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        vector<vector<int>> dp(n, vector<int>(n,0));\n        for (int c=0; c<n; c++) dp[n-1][c] = matrix[n-1][c];\n        for (int r=n-2; r>=0; r--)\n        {\n            for (int c=0; c<n; c++)\n            {\n                if (c==0) dp[r][c] = min(dp[r+1][c], dp[r+1][c+1]) + matrix[r][c];\n                else if (c==n-1) dp[r][c] = min(dp[r+1][c], dp[r+1][c-1]) + matrix[r][c];\n                else dp[r][c] = min(min(dp[r+1][c-1], dp[r+1][c]), dp[r+1][c+1]) + matrix[r][c];\n            }\n        }\n        int res=INT_MAX;\n        for (int c=0; c<n; c++) res = min(res, dp[0][c]);\n        return res;\n    }\n};\n```\n\nBTW, this algorithm is used in a smart image resizing method known as [Seam Carving](https://en.wikipedia.org/wiki/Seam_carving).","creationDate":1644162652}}},{"id":"1747252","title":"Min heap solution","url":"/discuss/topic/1747252/min-heap-solution","questionTitle":"Merge k Sorted Lists","post":{"creationDate":1644078281},"post_data":{"id":1747252,"title":"Min heap solution","solutionTags":[{"name":"Python"},{"name":"C"},{"name":"Heap (Priority Queue)"}],"post":{"id":3003531,"content":"Algorithm:\n- Create a min heap of the first item of each LL.\n- While min heap is not empty pop the top of heap and check which LL it is coming from.\n- Move ahead one step on that particular LL.\n- When heap is empty stop.\n\nC++ Version:\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n#define pi pair<int,int>\n#define mp make_pair\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) \n    {\n        int n=lists.size();\n        if (n==0) return NULL;\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\n        for (int i=0; i<n; i++)\n        {\n            auto list = lists[i];\n            if (list==NULL) continue;\n            pq.push(mp(list->val, i));\n            lists[i] = list->next;\n        }\n        ListNode *res = new ListNode;\n        ListNode *curr = res;\n        while (pq.size()>0)\n        {\n            pi p = pq.top();\n            pq.pop();\n            int val=p.first, idx=p.second;\n            curr->next = new ListNode(val);\n            curr = curr->next;\n            if (lists[idx] != NULL)\n            {\n                pq.push(mp(lists[idx]->val,idx));\n                lists[idx] = lists[idx]->next;                \n            }            \n        }\n        return res->next;\n    }\n};\n```\nPython version:\n```\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if lists is None or len(lists) == 0:\n            return None\n        lists = [lst for lst in lists if lst is not None]\n        import heapq\n        H = []\n        for i, lst in enumerate(lists):\n            heapq.heappush(H, (lst.val, i))\n            lst = lst.next\n        # print(H)\n        mylst = ListNode(None)\n        curr = mylst\n        while len(H) > 0:\n            # print(\"Heap\", H)\n            listval, listidx = heapq.heappop(H)\n            # print(listval, listidx)\n            curr.next = ListNode(listval)\n            if lists[listidx].next is not None:\n                lists[listidx] = lists[listidx].next\n                heapq.heappush(H, (lists[listidx].val, listidx))\n            curr = curr.next\n        return mylst.next\n```","creationDate":1644078281}}},{"id":"1743683","title":"Well-explained HashMap concise with pseudocode","url":"/discuss/topic/1743683/well-explained-hashmap-concise-with-pseudocode","questionTitle":"Contiguous Array","post":{"creationDate":1643955881},"post_data":{"id":1743683,"title":"Well-explained HashMap concise with pseudocode","solutionTags":[{"name":"C"}],"post":{"id":2997601,"content":"The key idea is to track how many ones and zeros we have seen from the beginning at any point. Let us keep an array that stores how many 1s and 0s we have seen at any point.\nSo, we start with counter=0 at the left end and then we can keep increase counter when we see 1 and decrease when we see 0. \nSo, for `[1,0,0,1,1]`, this will be `[1,0,-1,0,1]`.\nNow at any index if we want to find which all previous indexes we can find answers with, the answer is all the numbers which have the same number in this array. However we only want the smallest index to find the longest subarray. So, we don\"t need to actully go through the array. We can do better! Let use a hash map to store the min index for the counter. \nRunning through the same example, we will have the following hashmap:\nThe hashmap contains the first index where you achieve any value:\n`H={1:0, 0:1, -1:2}`\n\nThe candidate answer at any index is `i-H[ctr]`.\n\nOne tiny issue is if you think about `H` we have in fact seen 0 even before starting going trough the array. So `H[0]` will always be -1. For example if we later see at `i=5` that `ctr=0` then the possible answer is `5-(-1)`\n\nSo, H will actually be:\n`H={0:-1, 1:0, , -1:2}`\n\nNow we are ready for coding it up:\n```\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int ctr=0, res=0, n=nums.size();\n        unordered_map<int,int> H;\n        H[0]=-1;\n        for (int i=0; i<n; i++)\n        {\n            if (nums[i]==1) ctr++;\n            else ctr--;\n            if (H.count(ctr)) res = max(res, i-H[ctr]);\n            else H[ctr]=i;\n        }\n        return res;\n    }\n};\n```","creationDate":1643955881}}},{"id":"1743094","title":"DFS solution","url":"/discuss/topic/1743094/dfs-solution","questionTitle":"Max Area of Island","post":{"creationDate":1643930023},"post_data":{"id":1743094,"title":"DFS solution","solutionTags":[{"name":"Python"},{"name":"C"},{"name":"Depth-First Search"}],"post":{"id":2996655,"content":"```\nclass Solution {\npublic:\n    int util(int r, int c, vector<vector<int>> &grid, int m, int n, unordered_set<int> &visited)\n    {\n        if (r<0 || r>=m || c<0 || c>=n) return 0;\n        if (visited.count(n*r+c)>0 || grid[r][c]==0) return 0;\n        visited.insert(n*r+c);\n        return 1 + util(r-1,c,grid,m,n,visited) + util(r+1,c,grid,m,n,visited) + \\\n                   util(r,c-1,grid,m,n,visited) + util(r,c+1,grid,m,n,visited);\n    }\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int m=grid.size(), n=grid[0].size(), res=0;\n        unordered_set<int> visited;\n        for (int r=0; r<m; r++)\n            for (int c=0; c<n; c++)\n                res = max(res, util(r,c,grid,m,n,visited));\n        return res;\n    }\n};\n```\n```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        seen = set()\n        def util(r,c):\n            if r<0 or r>=m or c<0 or c>=n or (r,c) in seen or grid[r][c]==0:\n                return 0\n            seen.add((r,c))\n            return 1+util(r+1,c)+util(r-1,c)+util(r,c+1)+util(r,c-1)\n        return max([max([util(r,c) for c in range(n)]) for r in range(m)])\n```","creationDate":1643930023}}},{"id":"1743061","title":"Easy O(N^2) solution using HashMap","url":"/discuss/topic/1743061/easy-on2-solution-using-hashmap","questionTitle":"4Sum II","post":{"creationDate":1643927949},"post_data":{"id":1743061,"title":"Easy O(N^2) solution using HashMap","solutionTags":[{"name":"Python"},{"name":"C"}],"post":{"id":2996602,"content":"Create a hashmap H of all possible sums of `nums1` and `nums2` in O(N^2) time.\nThen traverse `nums3`X`nums4` in O(N^2) time and each time check membership in H.\nEasy-peasy!\n\nC++ version:\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        int n = nums1.size(), res=0;\n        unordered_map<int,int> H;\n        for (int n1: nums1) for (int n2: nums2) H[n1+n2]++;\n        for (int n3: nums3) for (int n4: nums4) if (H.count(-(n3+n4))) res+=H[-(n3+n4)];\n        return res;\n    }\n};\n```\nPython version:\n```\nclass Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        H = collections.defaultdict(int)\n        res = 0\n        for n1 in nums1:\n            for n2 in nums2:\n                H[n1+n2]+=1\n        for n3 in nums3:\n            for n4 in nums4:\n                if -(n3+n4) in H:\n                    res += H[-(n3+n4)]\n        return res\n```","creationDate":1643927949}}},{"id":"1743013","title":"C++ TLE vs Python AC issue","url":"/discuss/topic/1743013/c-tle-vs-python-ac-issue","questionTitle":"4Sum","post":{"creationDate":1643925074},"post_data":{"id":1743013,"title":"C++ TLE vs Python AC issue","solutionTags":[],"post":{"id":2996537,"content":"I have noticed several times that I am getting TLE while solving a problem in C++. Then when I write the exact same algorithm in python I get an AC. This could be because LC allows more time for python. Does this mean anything? Is it better to switch to python for this reason?\n\nEvidence:\n[4-Sum](https://leetcode.com/problems/4sum) throws TLE in C++ for this:\n```\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n=nums.size();\n        vector<vector<int>> res;\n        for (int i=0; i<n; i++)\n        {\n            for (int j=i+1; j<n; j++)\n            {\n                unordered_set<int> S;\n                for (int k=j+1; k<n; k++)\n                {\n                    if (S.count(nums[k])) \n                    {\n                        vector<int>quad {nums[i],nums[j],nums[k],target-nums[i]-nums[j]-nums[k]};\n                        sort(quad.begin(),quad.end());\n                        if (find(res.begin(), res.end(), quad)==res.end()) res.push_back(quad);\n                    }\n                    S.insert(target-nums[i]-nums[j]-nums[k]);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\nbut passes in python for this which is exactly the same.\n```\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        n = len(nums)\n        res = []\n        for i in range(n):\n            for j in range(i+1,n):\n                S = set()\n                for k in range(j+1,n):\n                    if nums[k] in S:\n                        quad = [nums[i],nums[j],nums[k],target-nums[i]-nums[j]-nums[k]]\n                        quad.sort()\n                        if quad not in res:\n                            res.append(quad)\n                    S.add(target-nums[i]-nums[j]-nums[k])\n        return res\n```","creationDate":1643925074}}},{"id":"1741322","title":"Easy min-heap solution","url":"/discuss/topic/1741322/easy-min-heap-solution","questionTitle":"Seat Reservation Manager","post":{"creationDate":1643874882},"post_data":{"id":1741322,"title":"Easy min-heap solution","solutionTags":[{"name":"C"},{"name":"Heap (Priority Queue)"}],"post":{"id":2993829,"content":"Algorithm:\n- At the beginning keep increasing counter at each reservation\n- When someone does unreserve, then store their seat number in a min heap\n- For a new booking try to first book from the heap. If heap is empty then increase your counter and book at `seat_number=counter`.\n```\nclass SeatManager {\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int ctr=0;\npublic:\n    SeatManager(int n) {\n    }\n    \n    int reserve() {\n        if (pq.size()==0) return ++ctr;\n        int minAvailable = pq.top();\n        pq.pop();\n        return minAvailable;\n    }\n    \n    void unreserve(int seatNumber) {\n        pq.push(seatNumber);\n    }\n};\n\n```","creationDate":1643874882}}},{"id":"1738772","title":"Simplest solution ever","url":"/discuss/topic/1738772/simplest-solution-ever","questionTitle":"Find All Anagrams in a String","post":{"creationDate":1643790254},"post_data":{"id":1738772,"title":"Simplest solution ever","solutionTags":[{"name":"Python"},{"name":"C"}],"post":{"id":2989772,"content":"If we look at the frequency map of s or p, we know it is at max of length 26. So why not just match them? Beats 62% of all solutions in c++ with this simple logic.\nC++ Version:\n```\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int ns = s.size(), np = p.size();\n        if (ns<np) return {};\n        vector<int> H_s(26,0), H_p(26,0);\n        for (char ch: p) H_p[ch-\"a\"]++;\n        for (char ch: string(s.begin(),s.begin()+np)) H_s[ch-\"a\"]++;\n        vector<int> res;\n        if (H_s==H_p) res.push_back(0);\n        for (int i=1; i<=ns-np; i++)\n        {\n            char ch1 = s[i-1], ch2=s[i+np-1];\n            H_s[ch1-\"a\"]--;\n            H_s[ch2-\"a\"]++;\n            if (H_s==H_p) res.push_back(i);\n        }\n        return res;\n    }\n};\n```\nPython version: (python has a `collections.Counter` that you can use to get frrequency map without writing code)\n```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n\t\tif len(s)<len(p) return []\n        H_p = collections.Counter(p)\n        H_s = collections.Counter(s[:len(p)])\n        res = []\n        if H_s==H_p:\n            res.append(0)\n        for i in range(1,len(s)-len(p)+1):\n            ch1, ch2 = s[i-1], s[i+len(p)-1]\n            H_s[ch1]-=1\n            H_s[ch2]+=1\n            if H_s==H_p:\n                res.append(i)\n        return res\n```\n\nComplexity: `O(26n)` or in other words `O(n)`","creationDate":1643790254}}},{"id":"1737524","title":"Well-explained O(n) easy to understand in C++","url":"/discuss/topic/1737524/well-explained-on-easy-to-understand-in-c","questionTitle":"Next Permutation","post":{"creationDate":1643744607},"post_data":{"id":1737524,"title":"Well-explained O(n) easy to understand in C++","solutionTags":[{"name":"C"}],"post":{"id":2987794,"content":"Steps:\n- Traverse through the array right to left, starting from `n-2` position (`n` is length of array)\n- If you find `a[i+1]>a[i]` stop.\n- If you reached `i=-1` means array is sorted in decreasing order. Reverse the whole array and return. Else follow next steps\n- Now remember that to the right of `i` we have decreasing sorted array (from `i+1` to `n-1`)\n- Reverse the array from `i+1` to `n-1` to make it increasing sorted.\n- Find the smallest number greater than `a[i]` in this portion and swap with `a[i]`. Remember there will always be at least one number greater than `a[i]` here because when you had stopped traversing, you had `a[i+1]>a[i]`, so at least that `a[i+1]` will still be there, but there still might be another more suitable candidate.\n- You are done!\n\nFor example\n```\nA = [9,8,4,8,6,4,3]\n```\nYou will stop at `i=2` because for the first time from right to left, `A[i+1]>A[i]`\nNow we see that we have a decreasing sorted array to the right of `i=2`: `[8,6,4,3]`. Reverse this part, so A now becomes:\n```\nA = [9,8,4,3,4,6,8]\n```\nNow traverse from `i=3` to end of array to find smallest number greater than `A[2]=4` and swap with `A[2]`. So we will have:\n```\nA=[9,8,6,3,4,4,8]\n```\nThis is indeed the correct answer.\n\nCoding it up:\n```\nclass Solution {\npublic:\n    void swap(int &a, int&b)\n    {\n        int t=a;\n        a=b;\n        b=t;\n    }\n    void nextPermutation(vector<int>& nums) {\n        if (nums.size()==1) return;\n        int n=nums.size(), i;\n        for (i=n-2; i>=0; i--)\n            if (nums[i+1]>nums[i]) break;\n        if (i==-1) {reverse(nums.begin(),nums.end()); return;}\n        sort(nums.begin()+i+1, nums.end());\n        int j;\n        for (j=i+1; j<n; j++) if (nums[j]>nums[i]) break;\n        swap(nums[i],nums[j]);\n        return;\n    }\n};\n```","creationDate":1643744607}}},{"id":"1717626","title":"[C++,Java,Python] Detailed easy to understand bitmask","url":"/discuss/topic/1717626/cjavapython-detailed-easy-to-understand-bitmask","questionTitle":"Maximum Good People Based on Statements","post":{"creationDate":1643087645},"post_data":{"id":1717626,"title":"[C++,Java,Python] Detailed easy to understand bitmask","solutionTags":[{"name":"Java"},{"name":"Python"},{"name":"C"}],"post":{"id":2956127,"content":"# Algorithm\nWe have a `statements` matrix of size n by n made up of elements 0,1,2 where \n- `statements[i][j]=1` means `person i` thinks `person j` is good.\n- `statements[i][j]=0` means `person i` thinks `person j` is bad.\n- `statements[i][j]=2` means `person i` doesnt comment on `person j`.\n\nWe also have these conditions:\n- Good person speaks truth always\n- Bad person can say truth or lie\n\nWe want to assign either 1 (for good) and 0 (for bad) to all persons in `0,1,..n-1` such that the `statements` matrix is feasible.\n\n## Pseudocode\nNow let us write our pseudocode to validate an assignment:\n```\nFOR i in 0,..,n-1\n\tFOR j in 0,..,n-1\n\t\t\tIF person i is good AND person j \\u2260  statement of person i on person j\n\t\t\t\tRETURN False\nRETURN True\n```\nWe simply need to run this for all possible assignments and if the assignment is valid we count the number of ones. At the end we return the maximum number of ones out of all valid assignments.\n\n## Bitmask\nNow, to use bitmask, let us have some notation:\nWe have `2^n` ways of doing the assignment (each person can be either good or bad). Let us denote an assignment as a variable caleld `number` which is in the range `[0,2^n-1]`.  If ith digit from left is 1 then in our assignment person i is assigned good and if ith digit from left is 0 then in our assignment person i is assigned bad.\nFor example say n is 3. The we can have 0,1,2,3,4,5,6,7 as possible assignments.\n0 in binary is `000` so means all bad\n1 in binary is `001` so means (0,1) are bad and 2 is good\n5 in binary is `101` so means (0,2) are good, 1 is bad\nand so on.\n\nNow let us write some logic we are gonna use later:\n#### How do we find if in our assignment ith person is assigned good or bad?\nFor exampel say our assignment is 5 ie `101`. Then\n- `5 & 4 > 0` means person 0 is assigned 1 ie good\n- `5 & 2 == 0` means person 1 is assigned 0 ie bad\n- `5 & 1 > 0` means person 2 is assigned  1 ie good\n\nBasically it is just a way of iterating over the binary representation of the number.\n\nNow that we have all the pieces let us write the code:\n\n<iframe src=\"https://leetcode.com/playground/8LL9m5Nw/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\n\nTime complexity: O((n^2 )* (2^n))\nSpace complexity: O(1)\n\nThis solution beats 80% of the solutions in terms of runtime and beats 95% of solutions in terms of memory. Please upvote if you found this helpful.","creationDate":1643087645}}},{"id":"1707414","title":"Serious and non-serious solution","url":"/discuss/topic/1707414/serious-and-non-serious-solution","questionTitle":"Add Binary","post":{"creationDate":1642783947},"post_data":{"id":1707414,"title":"Serious and non-serious solution","solutionTags":[],"post":{"id":2939951,"content":"Serious solution:\n```\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        string res;\n        int i = a.size()-1, j = b.size()-1;\n        int carry = 0;\n        while (i>=0 && j>=0)\n        {\n            int sum = carry + (a[i]-\"0\") + (b[j]-\"0\");\n            res.push_back(\"0\"+sum%2);\n            carry = (sum>1)?1:0;\n            i--; j--;\n        }\n        while (i>=0)\n        {\n            int sum = carry + (a[i]-\"0\");\n            res.push_back(\"0\"+sum%2);\n            carry = (sum>1)?1:0;\n            i--;\n        }\n        while (j>=0)\n        {\n            int sum = carry + (b[j]-\"0\");\n            res.push_back(\"0\"+sum%2);\n            carry = (sum>1)?1:0;\n            j--;\n        }\n        if (carry==1) res.push_back(\"0\"+carry);\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\nIf you want to troll LC:\n```\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return bin(int(a,2)+int(b,2))[2:]\n```","creationDate":1642783947}}},{"id":"1701129","title":"Easy BFS solution","url":"/discuss/topic/1701129/easy-bfs-solution","questionTitle":"N-ary Tree Level Order Traversal","post":{"creationDate":1642562228},"post_data":{"id":1701129,"title":"Easy BFS solution","solutionTags":[],"post":{"id":2929881,"content":"We had this solution for Level order traversal in Binary Tree:\n```\nvoid helper(TreeNode *root, vector<vector<int>> &res, int level)\n{\n\tif (!root) return;\n\tif (res.size()==level) res.push_back({});\n\tres[level].push_back(root->val);\n\thelper(root->left, res, level+1);\n\thelper(root->right, res, level+1);\n}\nvector<vector<int>> levelOrder(TreeNode* root) \n{\n\tvector<vector<int>> res;\n\thelper(root, res, 0);\n\treturn res;\n}\n```\n\nWe can modify this for N-ary tree as:\n```\nvoid helper(Node *root, vector<vector<int>> &res, int level)\n{\n\tif (!root) return;\n\tif (res.size()==level) res.push_back({});\n\tres[level].push_back(root->val);\n\tfor (auto child: root->children) helper(child, res, level+1);\n}\nvector<vector<int>> levelOrder(Node* root) \n{\n\tvector<vector<int>> res;\n\thelper(root, res, 0);\n\treturn res;\n}\n```","creationDate":1642562228}}},{"id":"1701064","title":"An easy and a difficult solution","url":"/discuss/topic/1701064/an-easy-and-a-difficult-solution","questionTitle":"Linked List Cycle II","post":{"creationDate":1642559318},"post_data":{"id":1701064,"title":"An easy and a difficult solution","solutionTags":[],"post":{"id":2929773,"content":"Easy method is to use hashset and traverse. If you find an element already present in hashset, return it. \n```\nListNode *detectCycle(ListNode *head) {\n\tListNode *curr = head;\n\tunordered_set<ListNode *> S;\n\twhile (curr)\n\t{\n\t\tif (S.find(curr)!=S.end()) return curr;\n\t\tS.insert(curr);\n\t\tcurr = curr->next;\n\t}\n\treturn NULL;        \n}\n```\nO(n) time and O(n) space complexity.\n\nFor O(1) space solution, we can use fast and slow pointers. If we encounter NULL ever, means there was no cycle. If cycle is present the two pointers will meet. Then we again traverse both slow and start nodes till they meet and then return it:\n```\nListNode *detectCycle(ListNode *head) {\n\tif (!head || !head->next) return NULL;\n\tListNode *start=head, *slow=head, *fast=head;\n\twhile (fast->next && fast->next->next)\n\t{\n\t\tslow = slow->next;\n\t\tfast = fast->next->next;\n\t\tif (slow==fast)\n\t\t{\n\t\t\twhile (start!=slow)\n\t\t\t{\n\t\t\t\tslow = slow->next;\n\t\t\t\tstart = start->next;\n\t\t\t}\n\t\t\treturn start;\n\t\t}\n\t}\n\treturn NULL;\n}\n```","creationDate":1642559318}}},{"id":"1672353","title":"Recursion+Memoization [cpp] Explained with intuitions step-wise","url":"/discuss/topic/1672353/recursionmemoization-cpp-explained-with-intuitions-step-wise","questionTitle":"House Robber III","post":{"creationDate":1641536096},"post_data":{"id":1672353,"title":"Recursion+Memoization [cpp] Explained with intuitions step-wise","solutionTags":[{"name":"C++"},{"name":"Recursion"},{"name":"Memoization"}],"post":{"id":2883972,"content":"Let us start at the `root` node. Assume that `root->left` and `root->right` are both non-NULL and define the following:\n```\nTreeNode *L= root->left\nTreeNode *R = root->right\nTreeNode *LL = root->left->left\nTreeNode *LR= root->left->right\nTreeNode *RL = root->right->left\nTreeNode *RR= root->right->right\n```\nNow, the recursive relation is:\n```\nrob(root)=max(rob(L)+rob(R),  root->val+rob(LL)+rob(LR)+rob(RL)+rob(RR))\n```\nIf `root->left` is NULL, then we replace `rob(LL)+rob(LR)` with the value zero. Thus we have the following relation:\n```\nrob(root)=max(rob(R),  root->val+rob(RL)+rob(RR))\n```\nSimilarly if `root->right` is NULL, we have the following relation\n```\nrob(root)=max(rob(L),  root->val+rob(LL)+rob(LR))\n```\n\n\n# Vanilla recursion Method\n\n```\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        if (root==NULL) return 0;\n        TreeNode *l=root->left, *r=root->right, *ll, *lr, *rl, *rr;\n        if (l){ll=l->left; lr=l->right;}\n        if (r){rl=r->left; rr=r->right;}\n        int a = (l)?rob(ll)+rob(lr):0;\n        int b = (r)?rob(rl)+rob(rr):0;\n        return max(root->val+a+b, rob(l)+rob(r));\n    }\n};\n```\nThe logic is perfectly correct in above algorithm and passes for the two test cases given in description. However on submission it gives `TLE` for large tree.\n\n# Memoization\n\nNotice that in the vanilla method, we are calculating the value for each node multiple times. Hence we can do memoization to reduce complexity. The idea is to use an HashMap ie `unordered_map<TreeNode *, int>`. At each node we return from the HashMap if present else calculate the value and add to the HashMap and then return the same.\n\n\n\n```\nclass Solution {\npublic:\n    int helper(TreeNode *root, unordered_map<TreeNode *, int> &money)\n    {\n        if (root==NULL) return 0;\n        if (money.find(root)!=money.end()) return money[root];\n        TreeNode *l=root->left, *r=root->right, *ll, *lr, *rl, *rr;\n        if (l){ll=l->left; lr=l->right;}\n        if (r){rl=r->left; rr=r->right;}\n        int a = (l)?helper(ll,money)+helper(lr,money):0;\n        int b = (r)?helper(rl,money)+helper(rr,money):0;\n        return money[root]=max(root->val+a+b, helper(l,money)+helper(r,money));\n    }\n    int rob(TreeNode* root) {\n        unordered_map<TreeNode *, int> moneys;\n        return helper(root, moneys);\n    }\n};\n```\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\nPlease upvote and comment if you found this useful.\n","creationDate":1641536096}}},{"id":"1669813","title":"Two easy to understand recursive solutions","url":"/discuss/topic/1669813/two-easy-to-understand-recursive-solutions","questionTitle":"Construct Binary Tree from Preorder and Inorder Traversal","post":{"creationDate":1641440695},"post_data":{"id":1669813,"title":"Two easy to understand recursive solutions","solutionTags":[{"name":"C"}],"post":{"id":2879793,"content":"## Method-I:\n- We know the root is at `preorder[0]`. Find the index of this element in `inorder` array. Call this `rootIndex`.\n- In the `inorder` array, everything to the left of this element is in the left subtree and everything to the right is in the right subtree ie `inorder[:rootIndex]` is the inorder traversal of left subtree and `inorder[rootIndex+1:]` is the inorder traversal of the right subtree\n- Now we can know the size of the left subtree and the right subtree from the above arrays. So we use this to form the preorder traversals of left and right subtree ie `preorder[1:rootIndex+1]` is the preorder traversal of left subtree and `preorder[rootIndex+1:]` is the preorder traversal of the right subtree\n- Recursively form the tree using the above 4 arrays as left and right.\n\n```\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (preorder.size()==0||inorder.size()==0) return NULL;\n\n        int rootIndex=0;\n        while(inorder[rootIndex]!=preorder[0])  rootIndex++;\n        vector<int> pre_left(preorder.begin()+1, preorder.begin()+rootIndex+1);\n        vector<int> pre_right(preorder.begin()+rootIndex+1, preorder.end());\n        vector<int> in_left(inorder.begin(), inorder.begin()+rootIndex);\n        vector<int> in_right(inorder.begin()+rootIndex+1, inorder.end());\n\n        TreeNode *root = new TreeNode;\n        root->val = preorder[0];\n        root->left = buildTree(pre_left, in_left);\n        root->right = buildTree(pre_right, in_right);\n        return root;\n    }\n};\n```\n\n## Method -II\nThis is similar to the solution provided by Leetcode in java. I translated it in c++.\n\nBasically we do the same method as method-I in a different manner. \n\n- Create a `HashMap<int, int>` and Keep indices of `inorder` array in the form `value: index`. \n- Initialize `preOrderIndex` as 0.\n- Both these variables are class variables so that these can be changed during the function calls.\n- Now we know that root is present at `preorder[0]`. So create the node with this value. Note that since we have a `preOrderIndex` variable, we can increment it and get this value from preorder array.\n- Use the index map created earlier to find the index of this element in the `inorder` array.\n- We know that to the left of this in `inorder` is the left subtree and to the right is the right subtree. So recursively call with appropriate left and right limits of inorder array.\n\n```\nclass Solution {\n    int preOrderIndex;\n    unordered_map<int,int> inOrderIndexMap;\npublic:\n    TreeNode *helper(vector<int>preorder, int left, int right)\n    {\n        if (left>right) return NULL;\n        int rootVal = preorder[preOrderIndex];\n        preOrderIndex++;\n        int inOrderIndex = inOrderIndexMap[rootVal];\n        TreeNode *root = new TreeNode;\n        root->val = rootVal;\n        root->left = helper(preorder, left, inOrderIndex-1);\n        root->right = helper(preorder, inOrderIndex+1, right);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        preOrderIndex=0;\n        for(int i=0; i<inorder.size(); i++) inOrderIndexMap[inorder[i]]=i;\n        return helper(preorder, 0, preorder.size()-1);\n    }\n};\n```\n\nI  personally  think method-I is easier and is what I would come up with when asked this problem during an interview.","creationDate":1641440695}}},{"id":"1653960","title":"Greedy Solution with easy to understand intuition [C++,Python]","url":"/discuss/topic/1653960/greedy-solution-with-easy-to-understand-intuition-cpython","questionTitle":"Check if a Parentheses String Can Be Valid","post":{"creationDate":1640752796},"post_data":{"id":1653960,"title":"Greedy Solution with easy to understand intuition [C++,Python]","solutionTags":[{"name":"Python"},{"name":"C"}],"post":{"id":2853220,"content":"Suppose there were no `locked` string and we need to only check if a given string is valid or not then we can do the following logic for forward:\n```\nint bal=0, n=s.size();\nfor (int i=0; i<n; i++)\n{\n\tif (s[i]==\"(\") bal++;\n\telse bal--;\n\tif (bal<0) return false;\n}\nreturn true;\n```\nAbove code checks orphan `)`. Now the following for backward  checks orphan `(`:\n```\nint bal = 0;\nfor (int i=n-1; i>=0; i--)\n{\n\tif (s[i]==\")\") bal++;\n\telse bal--;\n\tif (bal<0) return false;\n}\nreturn true;\n```\n\nTogether we can use both to check valid string:\n```\nbool isValid(string s) {\n\tif (s.size()%2==1) return false;\n\tint bal=0, n=s.size();\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (s[i]==\"(\" ) bal++;\n\t\telse bal--;\n\t\tif (bal<0) return false;\n\t}\n\tbal = 0;\n\tfor (int i=n-1; i>=0; i--)\n\t{\n\t\tif (s[i]==\")\") bal++;\n\t\telse bal--;\n\t\tif (bal<0) return false;\n\t}\n\treturn true;\n}\n```\n\nNow to solve our `canBeValid` problem we just need to add an extra condition as OR to allow one of the non-locked bracket to be inverted.\nC++:\n```\nclass Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if (s.size()%2==1) return false;\n        int bal=0, n=s.size();\n        for (int i=0; i<n; i++)\n        {\n            if (s[i]==\"(\" || locked[i]==\"0\") bal++;\n            else bal--;\n            if (bal<0) return false;\n        }\n        bal = 0;\n        for (int i=n-1; i>=0; i--)\n        {\n            if (s[i]==\")\" || locked[i]==\"0\") bal++;\n            else bal--;\n            if (bal<0) return false;\n        }\n        return true;\n    }\n};\n```\nPython:\n```\nclass Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        if len(s)%2==1: return False\n        bal = 0\n        for ch, lock in zip(s, locked):\n            if lock == \"0\" or ch == \"(\": bal += 1\n            else: bal -= 1\n            if bal < 0: return False \n        bal = 0\n        for ch, lock in zip(reversed(s), reversed(locked)): \n            if lock == \"0\" or ch == \")\": bal += 1\n            else: bal -= 1\n            if bal < 0: return False\n        return True\n```","creationDate":1640752796}}},{"id":"1653908","title":"Two ways to do topological sort","url":"/discuss/topic/1653908/two-ways-to-do-topological-sort","questionTitle":"Find All Possible Recipes from Given Supplies","post":{"creationDate":1640750796},"post_data":{"id":1653908,"title":"Two ways to do topological sort","solutionTags":[{"name":"Python"},{"name":"C"},{"name":"Topological Sort"}],"post":{"id":2853137,"content":"The first is the standard Kahn\"s Algorithm:\nPseudocode:\n- Construct adjacency list graph and inDegrees array\n- Create two arrays S and L both empty initially\n- Put all nodes of `supplies` in S\n- While S is not empty \n\t- Pop a node from S and insert in L\n\t- Traverse through adjacency list of this node and for each destination node in this adjacency list:\n\t  - Decrement `inDegree` of this destination node. This is equivalent to breaking an edge\n\t  - if `InDegree` is 0 then insert it into S\n\nNotice that at any point in the pseudocode, S consists of only nodes with zero `inDegree`.\n\n<iframe src=\"https://leetcode.com/playground/8NcX3sbt/shared\" frameBorder=\"0\" width=\"1000\" height=\"800\"></iframe>\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\nThe second is a cheat way to do topological sort in `O(n^2)` worse case time  complexity (You just keep traversing through the graph again and again till no new node is found). This should throw TLE in a proper contest/interview but surprisingly for me passed all the tests.\n<iframe src=\"https://leetcode.com/playground/Eyhyenv8/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>","creationDate":1640750796}}},{"id":"1620979","title":"C++ Basic solution","url":"/discuss/topic/1620979/c-basic-solution","questionTitle":"Robot Bounded In Circle","post":{"creationDate":1639115779},"post_data":{"id":1620979,"title":"C++ Basic solution","solutionTags":[],"post":{"id":2800324,"content":"After little bit of experimenting on paper, one can realize that the only situation that it does not land up at origin is if we do not end up on origin after one round and are also facing north.\nThe other two cases are:\n- Ending up on origin: Obviously it is `true`\n- Not ending up on origin but facing South/East/West: This is also true because after 2 rounds(South) or 4 rounds(East/West), we will again land at origin.\n\nNow for implementation, we will use three variables:\n- `a` for x-coordinate\n- `b` for y-coordinate\n- `c` for direction\n\nAll 3 are integers. One important thing to notice is that we can use `c` variable for direction as follows:\n- If you see \"L\",  increment c by 1\n- If you see \"R\", increment c by 3\n- If you see \"G\", do not change c\n\nFurther we can check which direction we are facing:\n- `c%4=0` means North\n- `c%4=1` means West\n- `c%4=2` means South\n- `c%4=3` means East\n\n\nNow the logic is that:\n- If you see G, find out which direction you are facing and modify the coordinates accordingly. This will change either a or b.\n- If you see L or R, change the variable c as per rule given above. Variables a and b do not change in this case.\n\n```\nclass Solution {\npublic:\n    bool isRobotBounded(string instructions) {\n        int a=0,b=0,c=0;\n        for(char ch: instructions)\n        {\n            if(ch==\"G\")\n            {\n                if(c%4==0)b++;\n                if(c%4==1)a--;\n                if(c%4==2)b--;\n                if(c%4==3)a++;\n            }\n            if(ch==\"L\") c++;\n            if(ch==\"R\") c+=3;\n        }\n        cout << a << \" \" << b << \" \" << c << endl;\n        if(c%4==0 && (a!=0 || b!=0)) return false;\n        return true;\n    }\n};\n```","creationDate":1639115779}}},{"id":"1319275","title":"Python easy to understand 3 line recursive solution","url":"/discuss/topic/1319275/python-easy-to-understand-3-line-recursive-solution","questionTitle":"Gray Code","post":{"creationDate":1625551249},"post_data":{"id":1319275,"title":"Python easy to understand 3 line recursive solution","solutionTags":[],"post":{"id":2322304,"content":"We see the pattern:\n```\n1: [0,1]\n2: [00,01,11,10]\n3: [000,001,011,010,110,111,101,100]\n```\nNotice the following recursive relation:\n```\ngrayCode(n) = [grayCode(n-1), new_part]\n```\n`new_part` consists of `1` added to the left of each item in reversed sequence of `grayCode(n-1)`.\n\nThis leads us to the following code:\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        if n==1: return [0,1]\n        prev = self.grayCode(n-1)\n        return prev + [2**(n-1)+i for i in prev[::-1]]\n```\nTime complexity: `O(n)`.","creationDate":1625551249}}}]